# 第二章
## C++的重要性质
### 虚函数与多态
省略，已经详细的记录在博客里。   
### new和malloc的区别
new和delete会调用构造函数及析构函数，而malloc不行。  
### 四种不同对象生存的方式（in stack、in heap、global、local static）   
在C++ 中，有四种方法可以产生一个对象。第一种方法是在堆栈（stack）之中产生它：   
```c   
void MyFunc()   
{   
	CFoo foo; // 在堆栈（stack）中产生foo 对象   
	...   
}   
```   
第二种方法是在堆积（heap）之中产生它：   
```c   
void MyFunc()   
{   
	...   
	CFoo* pFoo = new CFoo(); // 在堆（heap）中产生对象   
}   
```   
第三种方法是产生一个全域对象（同时也必然是个静态对象）：   
```
CFoo foo; // 在任何函数范围之外做此动作    
```    
第四种方法是产生一个区域静态对象：   
```c   
void MyFunc()   
{    
	static CFoo foo; // 在函数范围（scope）之内的一个静态对象    
	...   
}   
```   
不论任何一种作法，C++ 都会产生一个针对CFoo 构造函数的调用动作。   
前两种情况，C++在配置内存(来自栈stack或堆heap)之后立刻产生一个隐藏的（你的原代码中看不出来的）构造函数调用。   
第三种情况，由于对象实现于任何「函数活动范围」之外，显然没有地方来安置这样一个构造函数调用动作。是的，第三种情况（静态全域对象）的构造函数调用动作必须靠startup 码帮忙。   
startup 码是更早于程序进入点（main 或WinMain）执行起来的码，由C++ 编译器提供，被联结到你的程序中。startup 码可能做些像函数库初始化、进程信息设立、I/O stream 产生等等动作，以及对static 对象的初始化动作（也就是调用其构造函数）。    
当编译器编译你的程序，发现一个静态对象，它会把这个对象加到一个串行之中。更精确地说则是，编译器不只是加上此静态对象，它还加上一个指针，指向对象之构造函数及其参数（如果有的话）。把控制权交给程序进入点（main 或WinMain）之前，startup 码会快速在该串行上移动，调用所有登记有案的构造函数并使用登记有案的参数，于是就初始化了你的静态对象。    
第四种情况（区域静态对象）相当类似C语言中的静态区域变量，只会有一个实体产生，而且在固定的内存上（既不是stack也不是heap）。它的构造函数在控制权第一次移转到其声明处（也就是在MyFunc第一次被调用）时被调用。    