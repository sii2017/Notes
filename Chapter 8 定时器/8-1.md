# 定时器
Microsoft Windows定时器是一种输入设备，它周期性的在每经过一个指定的时间间隔后就通知应用程序一次。  
以下是windows定时器相关的一些应用：  
> **多任务**，将多个任务通过定时器分配成小块，每接收到一个WM_TIMER消息则处理一块。  
> **维护更新过的状态报告**，程序可以利用定时器持续的实时更新某个任务的进展情况。  
> **实作自动存储功能**，通过定时器在指定时间过去后将功使用者的工作存储到磁盘上。  
> **终止程序展示版本的执行**，一些程序的展示版本在固定时间后结束。时间已到，则定时器进行操作。  
> **步进移动**，游戏中的图形对象或计算机辅助教学程序中的连续显示，需要按指定的速率来处理。利用定时器可以消除由于微处理器速度不同而造成的不一致。  
> **多媒体**，一个程序可以使用定时器来周期性的检查已经播放了多少声音数据，并据此来协调屏幕上的视觉信息。  
## 定时器入门
可以通过SetTimer函数为windows程序分配一个定时器。该函数有一个时间范围从1毫秒到4294967295毫秒（将近50天）的整数型态参数。例如如果间隔1000毫秒则windows每秒给程序发送一个WM_TIMER消息。  
当程序用完定时器可以使用KillTimer函数来停止定时器消息。因此可以通过KillTimer函数来编写一个只使用一次的定时器。  
### 系统和定时器
总之在程序的进行中，不用担心程序被WM_TIMER消息意外中断。定时器类似于鼠标和键盘，驱动程序处理异步硬件中断时间。
### 定时器消息不是异步的
然而，WM_TIMER消息并不是异步的。他和其他消息是放在一起的，所以如果一个消息间隔时间是1000毫秒，他并不能在准确的1000毫秒收到。WM_TIMER是低优先级的，如果WM_PAINT一样，程序只有在消息队列中没有其他消息时才接收他们。换言之，WM_TIMER时间的精度一般可以使用，但是一些需要高精度定时器的程序中不宜使用。  
WM_TIMER还有一个特点与WM_PAINT相似：windows不能持续的向消息队列中放入多个WM_TIMER消息，而是将多余的WM_TIMER消息合并成一个消息。所以在短时间内的多个WM_TIMER消息可能会有**遗漏**。   
## 定时器的使用：三种方法
如果要在整个程序执行期间都使用到定时器，那么应该在WinMain函数中或者处理WM_CREATE的时候调用SetTimer，并且在退出WinMain或响应WM_DESTROY消息时调用KillTimer。
### 方法一
最方便的一种方法，让windows把WM_TIMER发送到应用程序的正常窗口消息处理程序中：  
```c
SetTimer(hwnd, 1, uiMsecInterval, NULL);  
```
第一个参数是接收消息的窗口句柄。第二个参数是定时器ID，是一个非0数值，当前假定为1。第三个参数是一个32位无正负号整数，以毫秒为单位。  
可以通过调用：  
```c
KillTimer(hwnd, 1);  
```
其中第二个参数就是定时器ID。在终止程序前，**应该响应WM_DESTROY消息停止任何活动的定时器**。  
当窗口消息处理函数收到WM_TIMER消息时，wParam参数为定时器ID，lParam参数为0。可以通过define定义不同的定时器ID。  
参考BEEPER1.c  
BEEPER1每次收到WM_TIMER消息时，都用颜色的变换显示出来并且发出蜂鸣声。     
### 方法二
第二种方法是让windows直接将定时器消息发送给程序的另一个函数。  
接收这些定时器消息的函数被称为callback函数，这是一个你的程序中但是由windows调用的函数。我们先告诉windows该函数的地址，然后windows调用该函数。  
事实上窗口消息处理函数也是一种callback函数，在注册窗口类别的时候会将函数的地址告诉Windows，于是发送消息给程序中，windows会调用次函数。  
callback函数的参数与返回值取决于该函数的目的。与定时器相关的callback函数，参数与窗口消息处理程序的参数一样，并且不会向windows传回值。  
例如我们将这个callback函数取名为TimerProc（这个可以任意选择不冲突的名字），那么在SetTimer函数中就要如此调用：  
```c
SetTimer(hwnd, iTimerID, iMsecInterval, TimerProc);  
```
第四个参数不再是NULL,而是接收消息的函数即地址。  
参考BEEPER2  
与BEEPER1相比将一些窗口消息的内容移植到了这个timerproc中，由于不是WM_PAINT消息所以使用了GetDC。  
WM_PAINT中不要使用GetDC，只能使用BeginPaint，因为BeginPaint能刷新无效区域成为有效区域，而GetDC不能，系统由于并不知道该区域重画过，以为还是无效区域，就会不断的重复发出WM_PAINT消息造成死循环。
### 方法三
设定定时器的第三种方法类似于第二种方法，只是传递给SetTimer的hwnd参数被设定为NULL，并且第二个参数（通常为定时器ID）被忽略了。最后此函数传回定时器ID：  
```c
iTimerID= SetTimer(NULL, 0, wMsecInterval, TimerProc);  
```
如果没有可用的定时器，那么传回的iTimerID将为NULL。  
KillTimer的第一个参数也必须为NULL，定时器ID必须是SetTimer的传回值：  
```c
KillTimer(NULL, iTimerID);  
```
这种方式很少用。  
ps：我暂时不认为这种方法有什么方便的。