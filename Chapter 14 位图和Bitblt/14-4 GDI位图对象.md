## GDI位图对象
本章前面已提到过Windows从1.0开始就支持GDI位图对象。因为在Windows 3.0发表了**设备无关位图**，之前的GDI位图对象有时也称为**设备相关位图**，或者**DDB**。   
对程序写作者来说，现存的两种不同型态的位图从Windows 3.0开始就更为混乱。许多有经验的Windows程序写作者都不能准确地理解DIB和DDB之间的关系。**诚然，DIB和DDB在许多方面是相关的：DIB与DDB能相互转换（尽管转换程序中会丢失一些信息）。然而DIB和DDB是不可以相互替换的，并且不能简单地选择一种方法来表示同一个可视数据。**    
如果我们能假设说DIB一定会替代DDB，那以后就会很方便了。但现实并不是如此，DDB还在Windows中扮演着很重要角色，尤其是您在乎程序执行表现好坏时。   
> 设备相关位图(DDB)与设备无关位图(DIB) 的区别   
> 1 设备相关位图DDB(Device-Dependent-Bitmap)不具有自己的调色板信息，他的颜色模式必须与输出设备相一致。如：在256色以下的位图中存储的像素值是系统调色板的索引，其颜色依赖于系统调色板。由于DDB高度依赖输出设备，所以DDB只能存在于内存中，它要么在视频内存中，要么在系统内存中。     
> 2 设备无关位图DIB(Device-Independent-Bitmap)具有自己的调色板信息，他可以不依赖系统的调色板。由于他不依赖于设备，所以通常用它来保存文件，如.bmp格式的文件就是DIB。    
### 建立DDB
DDB是Windows图形设备接口的图形对象之一（其中还包括绘图笔、画刷、字体、metafile和调色盘）。这些图形对象储存在GDI模块内部，由应用程序软件以句柄数字的方式引用。如：   
```c
HBITMAP hBitmap;    
```   
然后通过调用DDB建立的函数CreateBitmap（**第一个位图建立函数**）来获得句柄。这些函数配置并初始化GDI内存中的一些内存来储存关于位图的信息，以及实际位图位的信息。应用程序不能直接存取这段内存。当程序使用完位图后，就要清除内存：DeleteObject。    
```c
//以下为函数用法    
hBitmap= CreateBitmap (cx, cy, cPlanes, cBitsPixel, bits);    
DeleteObject (hBitmap);    
```    
CreateBitmap的前两个参数是位图的宽度和高度（以图素为单位），第三个参数是颜色面的数目，第四个参数是每图素的位数，第五个参数是指向一个以特定颜色格式存放的位数组的指针，**数组内存有用来初始化该DDB的图像**。如果不想用一张现有的图像来初始化DDB，可以将最后一个参数设为NULL，并且可以以后再设定该DDB内图素的内容。     
使用此函数时，也允许建立特定型态的GDI位图对象。例如，假设希望位图宽7个图素、高9个图素、5个?色位面，并且每个图素占3位，只需要这样编写：CreateBitmap(7, 9, 5, 3, NULL)。     
//这里分析了内存什么的，一顿操作，最后说明结论这个位图什么用都没有   
实际上，我们将用两种形态的参数来调用CreateBitmap。   
1 cPlanes和cBitsPixel都等于1（表示单色位图）    
2 cPlanes和cBitsPixel都等于某个特定设备内容的值，您可以使用PLANES和BITSPIXEL索引来从GetDeviceCaps函数获得。    
更现实的情况下我们只会用第一种情况来调用函数。对于第二种情况，我们可以用**第二个位图建立函数**CreateCompatibleBitmap来简化问题：   
```c
hBitmap = CreateCompatibleBitmap (hdc, cx, cy);   
```     
这个函数建立了一个与设备兼容的位图，第一个参数是设备内容句柄。CreateCompatibleBitmap用设备内容句柄来获得GetDeviceCaps信息，然后将此信息传递给CreateBitmap。除了与实际的设备内容有相同的内存组织之外，DDB与设备内容没有其它联系。    
**第三个位图建立函数**是CreateBitmapIndirect：   
```
hBitmap CreateBitmapIndirect (&bitmap);    
```   
其中bitmap是BITMAP型态的结构。BITMAP结构定义如下：   
```c
typedef struct _tagBITMAP   
{    
	LONG bmType ; // set to 0   
	LONG bmWidth ; // width in pixels   
	LONG bmHeight ; // height in pixels   
	LONG bmWidthBytes ; // width of row in bytes,不用设定windows将会自己计算      
	WORD bmPlanes ; // number of color planes   
	WORD bmBitsPixel ; // number of bits per pixel    
	LPVOIDbmBits ; // pointer to pixel bits   
}   
BITMAP, * PBITMAP ;   
```   
在调用CreateBitmapIndirect函数时，不需要设定bmWidthBytes字段，Windows将进行计算。我们也可以将bmBits字段设定为NULL，或者设定为初始化位图时用的图素位地址。    
GetObject函数内也使用BITMAP结构：   
```c
BITMAP bitmap;    
GetObject (hBitmap, sizeof (BITMAP), &bitmap);//Windows将用位图信息填充BITMAP结构的字段，不过，bmBits字段等于NULL。    
```    
最后应调用DeleteObject来清除程序内建立的所有位图。
### 位图位
用CreateBitmap或CreateBitmapIndirect来建立设备相关GDI位图对象时，您可以给**位图图素位**指定一个指针。或者您也可以让位图维持未初始化的状态。在建立位图以后，Windows还提供两个函数来获得并设定图素位。    
```c
SetBitmapBits (hBitmap, cBytes, &bits);//设定图素位   
GetBitmapBits (hBitmap, cBytes, &bits);//获取图素位   
//下一章他们将会被取代...
```   
cBytes指明要复制的字节数，bits是最少cBytes大小的缓冲区。    
对于非单色图，我们并不一定需要知道图素位的含义。例如：假定在8位颜色的VGA上执行Windows，我们可以调用CreateCompatibleBitmap。通过GetDeviceCaps能够确定正在处理一个有1个颜色位面和每图素8位的设备。**一个字节储存一个图素。但是图素值0x37是什么意思呢？**很明显是某种颜色，但到底是什么颜色呢？    
图素实际上并不涉及任何固定的颜色，它只是一个值。DDB没有颜色表。当DDB显示在屏幕上时，**具体是什么颜色将与在显示卡上的调色盘查看表里的0x37索引值代表的RGB颜色有关**。这就是我们现在碰到的设备依赖性。    
因此基本的规则如此：不要用CreateBitmap、CreateBitmapIndirect或SetBitmapBits来设定彩色DDB的位，您只能**安全地**使用这些函数来设定单色DDB的位。（如果在调用GetBitmapBits期间，从其它相同格式的DDB中获得位，那么这些规则例外。）    
//ps：这里我简单的概括一下，由于位图的像素位的自由度太高，并且它有着设备相关性，不同的设备颜色不同，所以如果设置彩色太不可控，并且换设备有可能引起颜色混乱    
以下，再说一下SetBitmapDimensionEx和GetBitmapDimensionEx函数。这些函数让您设定（和获得）位图的测量尺寸（以0.1毫米为单位）。这些信息与位图分辨率一起储存在GDI中，但不用于任何操作。它只是您与DDB联系的一个测量尺寸标识。
### 内存设备内容
我们需要用内存设备内容来处理GDI位图对象。   
通常，设备内容指的是特殊的图形输出设备（例如视讯显示器或者打印机）及其设备驱动程序。内存设备内容只位于内存中，它不是真正的图形输出设备，但可以说与指定的真正设备「兼容」。    
建立内存设备首先需要有实际设备的设备内容句柄hdc;  
```c
hdcMem = CreateCompatibleDC (hdc);   
```  
还有更简单的方法，如果将参数设为NULL，那么Windows将建立一个与视讯显示器相兼容的内存设备内容。应用程序建立的任何内存设备内容最终都通过呼叫DeleteDC来清除。     
内存设备内容有一个与实际位映像设备相同的显示平面（可以看作虚拟的显示屏）。不过，最初此显示平面非常小－单色、1图素宽、1图素高。显示平面就是单独1位。    
1位的显示平面是不够用的，因此可以通过将一个GDI位图对象选进内存设备内容来完成这项工作来扩大显示平面，例如：   
```c
//将之前创建的位图句柄（GDI对象）选进内存设备内容中     
SelectObject (hdcMem, hBitmap) ;     
```
内存设备内容是位图的唯一一种可以**被**选进的设备内容型态。（除了内存设备内容，位图没有办法被选进其它的设备内容了）如果需要，您也可以将其它GDI对象选进内存设备内容。    
> 只有选进内存设备内容的位图是单色的，或者与内存设备内容兼容设备有相同的色彩组织时，SelectObject才会起作用。这也是建立特殊的DDB（例如有5个位面，且每图素3位）没有用的原因。   

当SelectObject呼叫以后，DDB就是内存设备内容的显示平面（另外一个显示平面）。处理实际设备内容的每项操作，您几乎都可以用于内存设备内容。例如，如果用GDI画图函数在内存设备内容中画图，那么图像将画在位图上。这是非常有用的。还可以将内存设备内容作为来源，把视讯设备内容作为目的来呼叫BitBlt。这就是在显示器上绘制位图的方法。如果把视讯设备内容作为来源，把内存设备内容作为目的，那么呼叫BitBlt可将屏幕上的一些内容复制给位图。     
> Q 为什么要将位图选入内存再显示到画面上，不能直接在画面上处理位图嘛？    
> A 之所以将位图选入内存，然后再在内存上画，最后再将内存中画好的位图搬到屏幕上显示出来，主要的考虑是减少界面闪烁。因为你要是直接在屏幕上画图的话，当屏幕重绘时会闪烁得很厉害，当你在内存中画好，再将位图搬到屏幕上后，每次刷新时是把一幅完整的位图显示到屏幕上，并不需要重绘每个点，所以就不会看到闪烁了。深入了解可以搜索“双缓存”、“内存绘图”。    
### 载入位图资源
除了各种各样的位图建立函数以外，获得GDI位图对象句柄的另一个方法就是调用LoadBitmap函数。使用此函数，您不必担心位图格式。在程序中，只需简单地按资源来建立位图，这与建立图标或者鼠标光标的方法类似。LoadBitmap函数的语法与LoadIcon和LoadCursor相同：    
```c
hBitmap = LoadBitmap (hInstance, szBitmapName);     
//如果想加载系统位图，那么将第一个参数设为NULL。     
```   
由LoadBitmap加载的所有位图最后要使用DeleteObject清除。    
如果位图资源是单色的，那么从LoadBitmap传回的句柄将指向一个单色的位图对象。如果位图资源不是单色，那么从LoadBitmap传回的句柄将指向一个GDI位图对象，该对象与执行程序的视讯显示器有相同的色彩组织。**因此，位图始终与视讯显示器兼容**，并且总是能被选进与视讯显示器兼容的内存设备内容中。采用LoadBitmap呼叫后，就不用担心任何色彩转换的问题了。       
程序BRICKS1程序示范了加载一小张单色位图资源的方法。此位图本身不像砖块，但当它水平和垂直重复时，就与砖墙相似了。    
参考BRICKS1.C    
简单的用程序描述了以下     
> 1 关于位图的制作    
> 2 创建内存设备内容以及将位图拉入内存中    
> 3 将内存设备内容的位图复制到hdc设备内容    

原文说，Developer Studio建立的BRICKS.BMP文件是一个**设备无关位图**。(不知道为什么，难道是因为单色吗，还是因为它是由Developer Studio创建的？）    
### 单色位图格式
如果处理**小块单色图像**，那么不需要把他们当作资源来建立。与彩色位图不同，单色位的格式相对简单。     
如果下创建以下这个位图   
![](https://github.com/sii2017/image/blob/master/%E4%BD%8D%E5%9B%BE.jpg)   
可以写下一系列的位（0代表黑色，1代表白色），这些位直接对应于网格。从左到右读这些位，您能给每8字节配置一个十六进制元的字节值（等号右边的数字为左边每8个二进制数字的十六进制版本）。如果位图的宽度不是16的倍数，在字节的右边用零填充，以得到偶数个字节：     
0 1 0 1 0 0 0 1 0 1 1 1 0 1 1 1 0 0 0 1 = 51 77 10 00    
0 1 0 1 0 1 1 1 0 1 1 1 0 1 1 1 0 1 0 1 = 57 77 50 00   
0 0 0 1 0 0 1 1 0 1 1 1 0 1 1 1 0 1 0 1 = 13 77 50 00    
0 1 0 1 0 1 1 1 0 1 1 1 0 1 1 1 0 1 0 1 = 57 77 50 00    
0 1 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 = 51 11 10 00    
图素宽为20，扫描线高为5，字节宽为4。您可以用下面的叙述来设定此位图的BITMAP结构：   
```c
static BITMAP bitmap= { 0, 20, 5, 4, 1, 1 };   
```
并且可以将位储存在BYTE数组中：    
```c
static BYTE bits []=     
{     
	0x51, 0x77, 0x10, 0x00,    
	0x57, 0x77, 0x50, 0x00,    
	0x13, 0x77, 0x50, 0x00,    
	0x57, 0x77, 0x50, 0x00,    
	0x51, 0x11, 0x10, 0x00     
} ;     
```   
用CreateBitmapIndirect来建立位图需要下面两条叙述：   
```c
bitmap.bmBits =(PSTR) bits ;//将位信息存入BITMAP结构中    
hBitmap = CreateBitmapIndirect(&bitmap) ;      
```      
另一种方法：   
```c
hBitmap = CreateBitmapIndirect (&bitmap) ;    
SetBitmapBits (hBitmap, sizeof bits, bits) ;     
```     
也可以直接用一次调用就建立位图：   
```c
hBitmap = CreateBitmap (20, 5, 1, 1, bits);   
```    
BRICKS2程序利用此技术直接建立了砖块位图，而没有使用资源来创建位图。    
参考BRICKS2.C    
### 位图中的画刷
以下程序采用了更简便的方法，就是将原来要平铺的位图变成了背景画刷。   
唯一需要记住的是，画刷和位图都是GDI对象，用完以后要删除。    
参考BRICHS3.C
### 绘制位图
之前的程序中，我们已经将位图（内存设备内容）当成绘图来源使用过了。这要求先将位图选进内存设备内容，并呼叫BitBlt或者StretchBlt。   
我们也可以用内存设备内容句柄作为所有实际呼叫的GDI函数中的第一参数（目的）。内存设备内容的动作与实际的设备内容相同，除非显示平面是位图。    
以下HELLOBIT程序展示了此项技术。程序在一个小位图上显示了字符串「Hello, world!」，然后从位图到程序显示区域执行BitBlt或StretchBlt（依照选择的菜单选项而定）。
参考HELLOBIT.C    
该程序将字符串占满屏幕或者缩小平铺。    
过程为：取得字符串的长和宽，然后根据字符串的大小建立一个空的位图并且选入一个内存。然后在内存里（的位图上）输出字符串。但是，这不是显示大尺寸字符的好方法！它只是小字体的放大版，并带有放大时产生的锯齿线。
### 阴影位图
在内存设备内容绘图（也就是位图）的技术是执行「阴影位图（shadow bitmap）」的关键。**此位图包含窗口显示区域中显示的所有内容。**这样，对WM_PAINT消息的处理就简化到简单的BitBlt。    
阴影位图在绘画程序中最有用。下面的SKETCH程序并不是一个最完美的绘画程序，但它是一个开始。   
参考SKETCH.C     
**这是一个画图的程序。**     
创建一个屏幕最大尺寸的位图，然后将他作为“阴影位图”。     
所谓“阴影位图”的意思是在位图上画图，然后投射（复制）到实际的显示页面上去。    
Q1 为什么不直接画在显示区域？因为这个位图远大于显示的区域，所以就算画到显示区域外了，当我们拖动窗口也能看到之前看不到的。     
Q2 既然是画在位图上能不能删除画在hdc上的代码，试过但是不行，lineto可能是刷新显示区域的关键。    
### 在菜单中使用位图
我们也可以用位图在菜单上显示选项。  
GRAFMENU是展示图形菜单选项的范例程序。菜单上的位图，放大的字母来自于40×16图素的单色位图文件，该文件在Visual C++ Developer Studio建立。 以及一些其它的字体是用代码直接建立。    
参考GRAFMENU.C    
用位图替换菜单的显示。但是本程序无法实现，因为书中并未写明如何在不创建弹出菜单的情况下建立弹出菜单下面的子菜单。        
### 非矩形位图图像 
位图都是矩形的，但是并不需要都显示成矩形。   
我们可以通过屏蔽（mask）和一些位映像操作来解决这个问题。它与您要显示的矩形位图图像尺寸相同。每个屏蔽的图素都对应位图图像的一个图素。屏蔽图素是1(白色)，对应着位图图素显示；是0(黑色)，则显示背景色。（或者屏蔽位图与此相反，这根据您使用的位映像操作而有一些相对应的变化。）   
以下将通过程序实作，参考BITMASK.C    
在WM_CREATE中将原位图进行修改，修改成圆形。在WM_PAINT中将原图以圆形的方式放入hdc显示区域中。（这里用到了BiltBlt的两个新的模式，但是我觉得如果不常用这个功能，暂时不用了解这么深入）。    
ps：我觉得这个和ps的图层很相似。（而图层是我比较没天赋的一块）
### 简单的动画
位图和windows定时器联合使用，可以完成一些基本的动画。   
BOUNCE程序，是一个弹球游戏。它产生了一个在窗口显示区域弹来弹去的小球。该程序利用定时器来控制小球的行进速度。小球本身是一幅位图，程序首先通过建立位图来建立小球，将其选进内存设备内容，然后呼叫一些简单的GDI函数。程序用BitBlt从一个内存设备内容将这个位图小球画到显示器上。     
参考BOUNCE.C    
本程序将小球画在位图中，实际上不断改变的是位图的位置而不是小球本身，每0.5秒将位图复制到hdc中并且改变位置以供下一次复制使用。
### 窗口外的位图
以下这个程序作者说非常粗糙，但是比较有趣。在交换两个显示矩形内容的BitBlt操作的程序中，用内存设备内容作为临时储存空间。    
参考SCRAMBLE.C   
该程序锁定屏幕，整个屏幕出现方块形的马赛克并且在300次循环后逐步还原。    
这个程序中有一些没用过的罕见函数，但是看上去比较有用：   
```c
//锁住屏幕，防止其他程序更新屏幕画面    
LockWindowUpdate(hwnd= GetDesktopWindow())     
//获得整个屏幕的设备内容   
hdcScr= GetDCEx(hwnd, NULL, DCX_CACHE| DCX_LOCKWINDOWUPDATE);   
//接触屏幕的锁定    
LockWindowUpdate(NULL)      
```    
BLOWUP.C程序也用窗口更新锁定来在程序窗口之外显示一个捕捉的矩形。此程序允许使用者用鼠标圈选屏幕上的矩形区域，然后BLOWUP将该区域的内容复制到位图。在WM_PAINT消息处理期间，位图复制到程序的显示区域，必要时将拉伸或压缩。    
参考BLOWUP.C    