## 矩形、区域和裁剪
windows包含了几种使用RECT（矩形）结构和“区域”的绘图函数和。区域就是屏幕上的一块地方，它是矩形、多边形和椭圆的组合。  
### 矩形函数
下面三个绘图函数需要一个指向矩形结构的指针：  
```c
FillRect(hdc, &rect, hBrush); //使用画刷填入矩形 
FrameRect(hdc, &rect, hBrush);//用画刷画矩形框但是不填入颜色  
InvertRect(hdc, &rect);//将矩形中的像素进行反转  
```  
rect参数是一个RECT结构，包含四个字段：left、top、right和bottom。同样，作为使用hdc作为参数的函数，其中使用的也是逻辑坐标。  
windows还提供了9个函数，使我们可以更容易、更清楚的操作RECT结构。  
```c
SetRect(&rect, xLeft, yTop, xRight, yBottom);  
OffsetRect(&rect,x,y);//将矩形沿着xy轴移动几个单元    
InflateRect(&rect,x,y);//增减矩形的尺寸     
SetRectEmpty(&rect);//矩形各字段设为0    
CopyRect(&DestRect,&SrcRect);//将矩形复制给另一个矩形  
IntersertRect(&DestRect, &SrcRect1, &SrcRect2);//取得两个矩形的交集   
UnionRect(&DestRect, &SrcRect1, &SrcRect2);//取得两个矩形的联集  
bEmpty= IsRectEmpty(&rect);//确定矩形是否为空  
bInRect= PtInRect(&rect, point);//确定点是否在矩形内  
```
### 随机矩形
一个有趣的程序，简单使用随机的大小和色彩绘制一系列矩形。当然我们不能在WM_PAINT消息中简单的使用一个while(TRUE)，因为他会导致程序停止对其他消息的处理，控制权将在while中出不去，同理这个程序也不能中止或者最小化。  
```c
PeekMessage(&msg, NULL, 0, 0, PM_REMOVE);
```
前面四个参数，一个是指向MSG结构的指针、一个窗口句柄、两个值表示消息范围，与GetMessage的参数相同。将234个参数设定为NULL或0时，表示我们想让PeekMesage传回程序中所有窗口的所有消息。  
如果你希望删除消息，可以将最后一个参数设定为PM_REMOVE，如果不希望删除消息则设定为PM_NOREMOVE。这就是Peek_message为时“偷看”而不是“取得”消息的原因，它使程序可以检查队列的下一个消息而不实际删除它。  
> GetMessage不将控制权传回程序，直到从程序的消息队列中取得消息。  
> PeekMessage总是立刻传回，不论是否有消息。当它看到消息时传回TRUE，当没有看到消息时传回FALSE。  
  
我们通过改写循环来获取这种特性，我们将以下所示的循环：  
```c
while(GetMessage(&msg, NULL, 0, 0))  
{  
	TranslateMessage(&msg);  
	DispaatchMessage(&msg);  
}  
return msg.wParam;  
```
替换为下面的循环：  
```c
while(TRUE)  
{  
	if(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))//看到消息后删除  
	{  
		if(msg.message==WM_QUIT)  
			break;  
		TranslateMessage(&msg);  
		DispatchMessage(&msg);  
	}  
	else  
	{  
		//某些其他工作  
	}  
}  
return msg.wParam;  
```
注意，WM_QUIT消息被另外挑出来检查。在普通的循环中不用这么做，因为GetMessage收到WM_QUIT会传回零，但是PeekMessage收到WM_QUIT传回的仍旧是1，只有当他没收到消息才传回0，所以PeekMessage没有办法辨别收到的是不是WM_QUIT消息。  
参考RANDECT.C  
### 建立和绘制裁剪区域

### 矩形与区域的剪裁
### CLOVER程序
参考CLOVER.C  