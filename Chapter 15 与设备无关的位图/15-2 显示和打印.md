## 显示和打印
位图是用来看的。这一小节我们将看一下在显示器和打印页面上显示DIB的两个函数。之后我们会用更复杂的方式，但是提高性能的显示DIB。   
这两个函数称为SetDIBitsToDevice和StretchDIBits。每个函数都使用储存在内存中的DIB并能显示整个DIB或它的矩形部分。   
当使用SetDIBitsToDevice时，以图素为单位所显示映像的大小与DIB的图素大小相同。例如，一个640×480的DIB会占据整个标准的VGA屏幕，但在300dpi的激光打印机上它只有约2.1×1.6英寸。   
StretchDIBits能延伸和缩小DIB尺寸的行和列从而在输出设备上显示一个特定的大小。
### 了解DIB
正如前面所说，DIB文件包含下列部分：  
![](https://github.com/sii2017/image/blob/master/DIBData.jpg)  
在DIB文件被加载到内存后，除了文件表头File Header外，整个文件被存储在内存的连续区块中，指向内存块的开始处（信息表头的开头）的指针被称为指向packed DIB的指针。  
![](https://github.com/sii2017/image/blob/master/DIBDataInMemory.jpg)   
因为整个DIB由单个指针（如pPackedDib）引用，所以packed DIB是在内存中储存DIB的方便方法，可以把指针定义为指向BYTE的指针。使用本章前面所示的结构定义，能得到所有储存在DIB内的信息，包括色彩对照表和个别图素位。  
由于格式差异，DIB有可能是OS/2兼容格式的。在那种格式中，packed DIB以BITMAPCOREHEADER结构开始，并且DIB的图素宽度和高度以16位WORD，而不是32位LONG储存。因此，首先必须检查DIB是否为旧的格式，然后进行相对应的操作：   
```c
if(((PBITMAPCOREHEADER)pPackedDib)->bcSize== sizeof (BITMAPCOREHEADER))      
	iWidth= ((PBITMAPCOREHEADER) pPackedDib)->bcWidth;    
else    
	iWidth= ((PBITMAPINFOHEADER) pPackedDib)->biWidth;    
```    
对于SetDIBitsToDevice和StretchDIBits函数，需要的信息包括一个指向DIB的BITMAPINFO结构的指针(BITMAPINFO结构由BITMAPINFOHEADER结构和色彩对照表组成)。   
函数也需要一个指向图素位的指针。这个指针还是可以从信息表头内的信息推出。当存取BITMAPFILEHEADER结构的bfOffBits字段时，这个指针能很容易地计算出。bfOffBits字段指出了从DIB文件的开头到图素位的偏移量。我们可以简单地把此偏移量加到BITMAPINFO指标中，然后减去BITMAPFILEHEADER结构的大小。但是如果从剪贴簿上得到指向packed DIB的指标时就没有用，因为没有BITMAPFILEHEADER结构。  
SetDIBitsToDevice和StretchDIBits函数需要两个指向DIB的指标，因为这两个部分不在连续的内存块内。所以如果我们可以把DIB分成两个内存块是很有用的。   
![](https://github.com/sii2017/image/blob/master/DIB%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD.jpg)
### 点对点图素显示
SetDIBitsToDevice函数显示没有延伸和缩小的DIB。DIB的每个图素对应到输出设备的一个图素上，而且DIB中的图像一定会被正确显示出来－也就是说，图像的顶列在上方。任何会影响设备内容的坐标转换都影响了显示DIB的开始位置，但不影响显示出来的图片大小和方向。该函数如下：   
```c
iLines = SetDIBitsToDevice (
	hdc, // device context handle
	xDst, // x destination coordinate
	yDst, // y destination coordinate
	cxSrc, // source rectangle width
	cySrc, // source rectangle height
	xSrc, // x source coordinate
	ySrc, // y source coordinate
	yScan, // first scan line to draw
	cyScans, // number of scan lines to draw
	pBits, // pointer to DIB pixel bits
	pInfo, // pointer to DIB information
	fClrUse) ; // color use flag   
```   
和GDI显示函数一样，SetDIBitsToDevice的第一个参数是设备内容句柄，它指出显示DIB的设备。下面两个参数xDst和yDst，是输出设备的逻辑坐标，并指出了显示DIB图像左上角的坐标（「上端」指的是视觉上的上方，并不是DIB图素的第一行）。注意，这些都是逻辑坐标，因此它们附属于实际上起作用的任何坐标的映像方式。   
以显示整个DIB图像或仅显示其中的一部分，这就是后四个参数的作用。当显示整个DIB时，应把xSrc和ySrc设定为0，并且cxSrc和cySrc应分别等于DIB的图素宽度和高度。注意，因为BITMAPINFOHEADER结构的biHeight字段对于由上而下的DIB来说是负的，cySrc应设定为biHeight字段的绝对值（负的也是正的）。   
yScan和cyScan这两个参数在从磁盘文件或通过调制解调器读取数据时，通过每次显示DIB的一小部分来减少对内存的需求。通常，yScan设定为0，cyScan设定为DIB的高度。    
虽然BITMAPINFO结构的地址与BITMAPINFOHEADER结构的地址相同，但是SetDIBitsToDevice结构被定义为使用BITMAPINFO结构，暗示着：对于1位、4位和8位DIB，位图信息表头后必须跟着色彩对照表。尽管pInfo参数被定义为指向BITMAPINFO结构的指针，它也是指向BITMAPCOREINFO、BITMAPV4HEADER或BITMAPV5HEADER结构的指针。  
最后一个参数是DIB_RGB_COLORS或DIB_PAL_COLORS，在WINGDI.H内分别定义为0和1。如果您使用DIB_RGB_COLORS，这意味着DIB包含了色彩对照表。DIB_PAL_COLORS旗标指出，DIB内的色彩对照表已经被指向在设备内容内选定并识别的调色盘的16位索引代替。在下一章我们将学习这个选项。现在先使用DIB_RGB_COLORS，或者是0。    
SetDIBitsToDevice函数的返回值是所显示的扫描行的数目。  
程序SHOWDIB1通过使用SetDIBitsToDevice函数显示DIB。
参考SHOWDIB1.C DIBFILE.H DIBFILE.C    
这个程序主要功能是显示DIB，并且可以打开，保存DIB。需要关注有二：   
1 使用了DIBFILE.C中封装的一些API函数。   
2 对DIB进行了判断，是老版本还是新版本：   
旧的DIB形式以BITMAPFILEHEADER结构开始，接着BITMAPCOREHEADER结构。新版本扩展DIB同样以BITMAPFILEHEADER结构开始，但是接着是BITMAPINFOHEADER结构。   
由于加载到内存中，会省去开头的BITMAPFILEHADER结构，所以直接套用类型指针，就可以判断了。   
当然，SHOWDIB1还缺少一些功能。例如，如果DIB对显示区域来说太大，则没有滚动条可用来移动查看。在下一章的末尾将修改这些缺陷。    
### DIB的颠倒世界

参考APOLLO11.C
### 循环显示
参考SEQDISP.C
### 缩放到合适尺寸
参考SHOWDIB2.C
### 色彩转换、调色盘和显示效能