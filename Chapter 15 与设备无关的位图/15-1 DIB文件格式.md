# 第十五章 与设备无关的位图
上一张了解了GDI位图对象（设备相关位图，DDB）。  
但是并没有展示把这些位图储存到磁盘文件或把它们加载内存的方法。这是以前在Windows中使用的方法，现在根本不用了。DDB位图依赖设备，没有自己的调色盘，所以不适合作为图像交换。DDB只有在Windows开机到关机的生命期内被建立和清除时才有意义。   
在Windows 3.0中发表了与**设备无关的位图(DIB)**，提供了适用于交换的图像文件格式。像.GIF或.JPEG之类的其它图像文件格式在Internet上比DIB文件更常见。这是因为.GIF和.JPEG格式进行了压缩可以明显减少下载时间。尽管有一个用于DIB的压缩方案，但极少使用。DIB内的位图几乎都没有被压缩。如果您想在程序中操作位图，这实际上是一个优点。有windowsAPI直接支持DIB，但是没有支持GIF和JPEG。
## DIB文件格式
DIB格式并不是windows开发的。它首先定义在OS/2的1.1版中。然后在Windows 3.0中（发布于1990）使用了OS/2位图格式，这时称之为DIB。Windows 3.0也包含了原始DIB格式的变体，并在Windows下成为标准。    
DIB首先作为一种文件格式，它的扩展名为.BMP，在极少情况下为.DIB。Windows应用程序使用的位图图像被当做DIB文件建立，并作为只读资源储存在程序的可执行文件中。   
程序能将DIB文件减去前14个字节加载连续的内存块中。这时就可以称它为**packed DIB（packed-DIB）格式的位图**。在Windows下执行的应用程序能使用packed DIB格式，通过Windows剪贴簿来交换图像或建立画刷。程序也可以完全存取DIB的内容并以任意方式修改DIB。   
程序也能在内存中建立自己的DIB然后把它们存入文件。**程序使用GDI函数呼叫就绘制**这些DIB内的图像，也能在程序中利用别的内存DIB直接设定和操作图素位。在内存中加载了DIB后，程序也能通过几个Windows API函数呼叫来使用DIB数据。   
### OS/2样式的DIB
先看一下在OS/2 1.1中出现的位图格式兼容的Windows DIB格式。   
> DIB文件四个部分：   
> 文件表头    
> 信息表头   
> RGB色彩对照表（不一定有）    
> 位图图素位    


可以把前两部分看成C的数据结构（文件表头和信息表头），第三部分看成数据结构的数组（RGB色彩对照表）。    
而在内存中的packed DIB格式（即程序能将DIB文件减去前14个字节加载连续的内存块中）有三个部分：    
> 信息表头   
> RGB色彩对照表（不一定有）   
> 位图图素位    


除了没有文件表头外（被程序删除了），其它与存储在文件里的DIB相同。   
而存在文件里的DIB文件，则是以如下结构的14个字节的文件表头开始：   
```c
typedef struct tagBITMAPFILEHEADER // bmfh(bitmap file header)       
{     
	WORD bfType; //signature word "BM" or 0x4D42    
	DWORD bfSize; //entire size of file    
	WORD bfReserved1; //must be zero    
	WORD bfReserved2; //must be zero    
	DWORD bfOffsetBits; //offset in file of DIB pixel bits    
}    
BITMAPFILEHEADER, * PBITMAPFILEHEADER ;     
```    
结构的长度为14字节，它以两个字母「BM」开头以指明是位图文件。这是一个WORD值0x4D42。紧跟在「BM」后的DWORD以字节为单位指出了包括文件表头在内的文件大小。下两个WORD字段设定为0。（在与DIB文件格式相似的鼠标光标文件内，这两个字段指出光标的「热点（hot spot）」）。结构还包含一个DWORD字段，它指出了文件中图素位开始位置的字节偏移量。此数值来自DIB信息表头中的信息，为了使用的方便提供在这里。   
在OS/2样式的DIB内，BITMAPFILEHEADER(文件表头）结构后紧跟BITMAPCOREHEADER（信息表头）结构，它提供了关于DIB图像的基本信息。紧缩的DIB（Packed DIB）开始于BITMAPCOREHEADER：    
```c
typedef struct tagBITMAPCOREHEADER // bmch(bitmap core header)/信息表头    
{    
	DWORD bcSize; //size of the structure = 12    
	WORD bcWidth; //width of image in pixels    
	WORD bcHeight; //height of image in pixels    
	WORD bcPlanes; //= 1    
	WORD bcBitCount; //bits per pixel (1, 4, 8, or 24)    
}    
BITMAPCOREHEADER, * PBITMAPCOREHEADER ;       
```   
**bcSize字段**指出了数据结构的大小，在这种情况下是12字节。**bcWidth和bcHeight**字段包含了以图素为单位的位图大小。这意味着一个DIB最大可能为65,535图素高和宽，但是我们几乎不会用到那么大的单位。**bcPlanes字段**的值始终是1。这个字段是我们在上一章中遇到的早期Windows GDI位图对象的残留物。**bcBitCount字段**指出了每图素的位数。对于OS/2样式的DIB，这可能是1、4、8或24。DIB图像中的颜色数等于1<<bmch.bcBitCount。   
于是，1代表2色DIB，4代表16色DIB，8代表256色DIB，24代表full-color DIB。 即每个图素的位数。   
对于前3种情况（1、4、8），BITMAPCOREHEADER后紧跟色彩对照表，24位DIB是没有色彩对照表的。**色彩对照表是一个3字节的RGBTRIPLE结构的数组，数组中的每个元素代表图像中的每种颜色。**    
```c
typedef struct tagRGBTRIPLE // rgbt/颜色对照表    
{    
	BYTE rgbtBlue; // 蓝色level   
	BYTE rgbtGreen; // 绿色level   
	BYTE rgbtRed; // 红色level   
}    
RGBTRIPLE ;   
```
**这样排列色彩对照表以便DIB中最重要的颜色首先显示**，我们将在下一章说明原因。     
WINGDI.H表头文件也定义了下面的结构：   
```c
typedef struct tagBITMAPCOREINFO //bmci   
{    
	BITMAPCOREHEADER bmciHeader; //core-header structure信息表头    
	RGBTRIPLE bmciColors[1]; //color table array颜色表       
}    
BITMAPCOREINFO, * PBITMAPCOREINFO ;    
```   
这个结构把信息表头与色彩对照表结合起来。虽然在这个结构中RGBTRIPLE结构的数量等于1，但在一般的DIB文件内RGBTRIPLE不会是1。根据每个图素的位数，色彩对照表的大小始终是（分别对应148）2、16或256个RGBTRIPLE结构。    
如果需要为8位DIB配置PBITMAPCOREINFO结构：  
```c
pbmci = malloc (sizeof (BITMAPCOREINFO) + 255 * sizeof (RGBTRIPLE)) ;    
```    
然后可以这样存取RGBTRIPLE结构：pbmci->bmciColors[i]    
因为RGBTRIPLE结构的长度是3字节，许多RGBTRIPLE结构可能在DIB中以奇数地址开始。然而，因为在DIB文件内始终有偶数个的RGBTRIPLE结构，所以紧跟在色彩对照表数组后的数据块总是以WORD地址边界开始。（ps，这段与内存相关的，目前还不太懂）    
紧跟在色彩对照表（24位DIB中是信息表头，没有色彩对照表）后的数据是图素位本身。
### 由下而上
像大多数位图格式一样，DIB中的图素位是以水平行组织的，用视讯显示器硬件的术语称作「扫描线」。行数等于BITMAPCOREHEADER结构的bcHeight字段。然而，与大多数位图格式不同的是，**DIB从图像的底行开始，往上表示图像**。    
我们说的“顶行”和“低行”是指虚拟图像的顶部和底部，但是我们说DIB文件的“第一行”是指代码的第一行，但是是虚拟图像的底部。总而言之，顶行和底行是按照虚拟图像来表示，而第一行和最后一行是根据代码来表示。     
至于为什么这样呢？    
> 简而言之，数学方法赢了。PM内的所有事物都以左下角为原点（包括窗口坐标），因此DIB也就有了那种方式。   
### DIB图素位
DIB文件的最后部分（在大多数情况下是DIB文件的主体）由实际的DIB的图素字节成。图素位是由从图像的底行开始并沿着图像向上增长的水平行组织的。    
DIB中的行数等于BITMAPCOREHEADER结构的bcHeight字段。每一行的图素数等于该结构的bcWidth字段。每个图素的位数可
以从bcBitCount字段取得，为1、4、8或24。    
以字节为单位的每行长度始终是4的倍数。行的长度可以计算为：    
```c
RowLength = 4 * ((bmch.bcWidth * bmch.bcBitCount + 31) / 32) ;     
RowLength = ((bmch.bcWidth * bmch.bcBitCount + 31) & ~31) >> 3 ;//或    
```    
图素数据的总字节数等于RowLength和bmch.bcHeight的乘积。   要了解图素编码的方式，让我们分别考虑四种情况。以下会做一个总结，细节可以参考P778。    
由于每个字节有8位，那么对于每图素1位的DIB，每个字节可以容纳8图素；对于每图素4位的DIB，每个字节可以容纳2图素；对于每图素8位的DIB，每个字节可以容纳1个图素；而对于每个图素24位的DIB，则三个字节对应一个图素。   
对于每图素1位的DIB，是单色位图，即黑和白，所以只需要两位，每个图素可以是0或1，代表两种颜色。0表示该图素的颜色由色彩对照表中第一个RGBTRIPLE项目给出。1表示图素的颜色由色彩对照表的第二个项目给出。   
同理，每图素4位的DIB，每四位的值的范围是从0到15，代表16种颜色。每图素8位的DIB，每8位即一个字节的值从0到255。   
最后，对于对于每图素24位的DIB，每个图素需要3个字节来代表红、绿和蓝的颜色值。**图素位的每一行，基本上就是RGBTRIPLE结构的数组**，所以他也没有色彩对照表没，可能需要在每行的末端补0以便该行为4字节的倍数。    
### 扩展的windows DIB
上面我们了解了Windows 3.0中介绍的与OS/2兼容的DIB，同时也看一看Windows中DIB的扩展版本。这种DIB形式跟前面的格式一样，以BITMAPFILEHEADER结构开始，但是接着是BITMAPINFOHEADER结构，而不是BITMAPCOREHEADER结构：    
```c
typedef struct tagBITMAPINFOHEADER // bmih(bitmap info head)    
{    
	DWORD biSize; //size of the structure = 40   
	LONG biWidth; //width of the image in pixels     
	LONG biHeight; //height of the image in pixels   
	WORD biPlanes; //=1   
	WORD biBitCount; //bits per pixel(1, 4, 8, 16, 24, or 32)   
	DWORD biCompression; //compression code   
	DWORD biSizeImage; //number of bytes in image   
	LONG biXPelsPerMeter; //horizontal resolution   
	LONG biYPelsPerMeter; //vertical resolution  
	DWORD biClrUsed; //number of colors used   
	DWORD biClrImportant; //number of important colors    
}   
BITMAPINFOHEADER, * PBITMAPINFOHEADER ;   
```   
可以通过检查结构的第一字段区分与OS/2兼容的DIB和Windows DIB，前者为12，后者为40。   
BITMAPINFOHEADER是由BITMAPCOREHEADER加上一些新字段而成。其中原来的字段biWdth和biHeight字段由16位的WORD值变成了32位的LONG值。   
另一个变化是：对于使用BITMAPINFOHEADER结构的1位、4位和8位DIB，色彩对照表不是RGBTRIPLE结构的数组。相反，BITMAPINFOHEADER结构紧跟着一个RGBQUAD结构的数组：   
```c
typedef struct tagRGBQUAD // rgb   
{   
	BYTE rgbBlue ; // blue level   
	BYTE rgbGreen ; // green level   
	BYTE rgbRed ; // red level   
	BYTE rgbReserved ; //always be 0   
}   
RGBQUAD ;    
```   
除了包括总是设定为0的第四个字段外，与RGBTRIPLE结构相同。 WINGDI.H表头文件也定义了以下结构：（WINGDI.H中也将BITMAPCOREHEADER信息表头和RGBTRIPLE定义在一起，这里是扩展版的信息表头和扩展版的调色盘）     
```c    
typedef struct tagBITMAPINFO // bmi    
{     
	BITMAPINFOHEADER bmiHeader ; // info-header structure     
	RGBQUAD bmiColors[1] ; // color table array     
}    
BITMAPINFO, * PBITMAPINFO ;    
```     
注意，如果BITMAPINFO结构以32位的地址边界开始，因为BITMAPINFOHEADER结构的长度是40字节，所以RGBQUAD数组内的每一个项目也以32位边界开始。这样就确保通过32位微处理器能更有效地对色彩对照表数据寻址。    
尽管BITMAPINFOHEADER最初是在Windows 3.0中定义的，但是许多字段在Windows 95和Windows NT 4.0中又重新定义了，并且被带入Windows 98和Windows NT 5.0中。**比如现在的文件中说：「如果biHeight是负数，则位图是由上而下的DIB，原点在左上角」**。      
**biPlanes和biBitCount**    
biPlanes字段始终是1，但biBitCount字段现在可以是16或32以及1、4、8或24。这也是在Windows 95和Windows NT 4.0中的新特性。    
**biXPelsPerMeter和biYPelsPerMeter**    
**biXPelsPerMeter和biYPelsPerMeter字段以每公尺多少图素这种笨拙的单位指出图像的实际尺寸。**（「pel」--picture element（图像元素）--是IBM对图素的称呼。）Windows在内部不使用此类信息。然而，应用程序能够利用它以准确的大小显示DIB。如果DIB来源于没有方图素的设备，这些字段是很有用的。**在大多数DIB内，这些字段设定为0，这表示没有建议的实际大小**。   
**biClrUsed**    
biClrUsed是非常重要的字段，因为它影响色彩对照表中项目的数量。对于4位和8位DIB，它能分别指出色彩对照表中包含了小于16或256个项目。**总结**如下：   
对于1位DIB，biClrUsed始终是0或2。色彩对照表始终有两个项目。      
对于4位DIB，如果biClrUsed字段是0或16，则色彩对照表有16个项目。如果是从2到15的数，则指的是色彩对照表中的项目数。每个图素的最大值是小于该数的1。    
对于8位DIB，如果biClrUsed字段是0或256，则色彩对照表有256个项目。如果是从2到225的数，则指的是色彩对照表中的项目数。每个图素的最大值是小于该数的1。    
对于16位、24位或32位DIB，biClrUsed字段通常为0。如果它不为0，则指的是色彩对照表中的项目数。执行于256色显示卡的应用程序能使用这些项目来为DIB设定调色盘。   
> 另一个警告：原先使用早期DIB文件编写的程序不支持24位DIB中的色彩对照表，如果在程序使用24位DIB的色彩对照表的话，就要冒一定的风险。   
> ps:好像并没有说到24位都用调色盘了，可以看作24位位图使用调色盘是少数情况？    

**biClrImportant**     
biClrImportant字段为**位图显示过程中重要的颜色数**，通常被设定为0以指出色彩对照表中所有的颜色都是重要的，或者它与biClrUsed有相同的值。两种方法意味着同一件事，如果它被设定为0与biClrUsed之间的值，就意味着DIB图像能仅仅通过色彩对照表中第一个biClrImportant项目合理地取得。当在256色显示卡上并排显示两个或更多8位DIB时，这是很有用的。（后面半句存疑）    
对于1位、4位、8位和24位的DIB，图素位的组织和OS/2兼容的DIB是相同的，一会儿我将讨论16位和32位DIB。
### 真实检查
最普遍的DIB可能是每图素8位。8位DIB分为两类：灰阶DIB和混色DIB。不过，表头信息中并没有指出8位DIB的型态。   
许多灰阶DIB有一个等于64的biClrUsed字段，指出色彩对照表中的64个项目。这些项目通常以上升的灰阶层排列，也就是说色彩对照表以00-00-00、04-04-04、08-08-08、0C-0C-0C的RGB值开始，并包括F0-F0-F0、F4-F4-F4、F8-F8-F8和FC-FC-FC的RGB值。此类色彩对照表可用下列公式计算：    
rgb[i].rgbRed = rgb[i].rgbGreen = rgb[i].rgbBlue = i * 256 / 64;    
在这里rgb是RGBQUAD结构的数组，i的范围从0到63。灰阶色彩对照表可用下列公式计算：   
rgb[i].rgbRed = rgb[i].rgbGreen = rgb[i].rgbBlue = i * 255 / 63;      
因而此表以FF-FF-FF结尾。   
> ps（个人猜测）由于灰度的调色板的RGB都相等，所以他只要256色的三分之一就够了，所以他只有64个项目。    

**当某些8位灰阶DIB在色彩对照表内有64个项目时，其它灰阶的DIB会有256个项目。**biClrUsed字段实际上可以为0（指出色彩对照表中有256个项目）或者从2到256的数。当然，biClrUsed值是2的话就没有任何意义（因为这样的8位DIB能当作1位DIB被重新编码，因为1位DIB就只有2个项目）或者小于或等于16的值也没意义（因为它能当作4位DIB被重新编码，4位DIB是16个项目）。任何情况下，色彩对照表中的项目数必须与biClrUsed字段相同（如果biClrUsed是0，则是256），并且图素值不能超过色彩对照表项目数减1的值。这是因为图素值是指向色彩对照表数组的索引。对于biClrUsed值为64的8位DIB，图素值的范围从0x00到0x3F。    
在这里应记住一件重要的事情：当8位DIB具有由整个灰阶组成的色彩对照表（也就是说，当红色、绿色和蓝色程度相等时），或当这些灰阶层在色彩对照表中递增时，图素值自身就代表了灰色的程度。也就是说，如果biClrUsed是64，那么0x00图素值为黑色，0x20的图素值是50%的灰阶，0x3F的图素值为白色。这对于一些图像处理作业是很重要的，**因为我们可以完全忽略色彩对照表，仅需处理图素值**。    
混色的8位DIB一般使用整个色彩对照表，它的biClrUsed字段为0或256。然而也可能遇到较小的颜色数，如236。需要注意的是，程序通常只能在Windows颜色面内更改236个项目以正确显示这些DIB，我们将在下章讨论这些内容。   
biXPelsPerMeter 和biYPelsPerMeter 很少为非零值，biClrImportant 字段不为0或biClrUsed值的情况也很少。
### DIB压缩
**biCompression字段**    
biCompression字段可以为四个常数之一，它们是：BI_RGB、BI_RLE8、BI_RLE4或BI_BITFIELDS。它们定义在WINGDI.H表头文件中，值分别为0到3。   
此字段有两个用途：    
对于4位和8位DIB，它指出图素位被用一种运行长度（run-length）编码方式压缩了。对于16位和32位DIB，它指出了颜色屏蔽（color masking）是否用于对图素位进行编码。    
> RLE（run-length）压缩：   
> 对于1位DIB，biCompression字段始终是BI_RGB。   
> 对于4位DIB，biCompression字段可以是BI_RGB或BI_RLE4。   
> 对于8位DIB，biCompression字段可以是BI_RGB或BI_RLE8。    
> 对于24位DIB，biCompression字段始终是BI_RGB。    

如果值是BI_RGB，图素位储存的方式和OS/2兼容的DIB一样，否则就使用了运行长度编码压缩图素位。   
运行长度编码（RLE）是一种最简单的数据压缩形式，它是根据DIB映射在一列内经常有相同的图素字符串这个事实进行的。**RLE通过对重复图素的值及重复的次数编码来节省空间**，而用于DIB的RLE方案只定义了很少的矩形DIB图像，也就是说，矩形的某些区域是未定义的，这能被用于表示非矩形图像。   
### 颜色掩码
### 第四版本的Header
### 第五版本的Header
### 显示DIB信息
参考DIBHEADS.C  