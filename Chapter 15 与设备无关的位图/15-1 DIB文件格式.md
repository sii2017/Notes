# 第十五章 与设备无关的位图
上一张了解了GDI位图对象（设备相关位图，DDB）。  
但是并没有展示把这些位图储存到磁盘文件或把它们加载内存的方法。这是以前在Windows中使用的方法，现在根本不用了。DDB位图依赖设备，没有自己的调色盘，所以不适合作为图像交换。DDB只有在Windows开机到关机的生命期内被建立和清除时才有意义。   
在Windows 3.0中发表了与**设备无关的位图(DIB)**，提供了适用于交换的图像文件格式。像.GIF或.JPEG之类的其它图像文件格式在Internet上比DIB文件更常见。这是因为.GIF和.JPEG格式进行了压缩可以明显减少下载时间。尽管有一个用于DIB的压缩方案，但极少使用。DIB内的位图几乎都没有被压缩。如果您想在程序中操作位图，这实际上是一个优点。有windowsAPI直接支持DIB，但是没有支持GIF和JPEG。
## DIB文件格式
DIB格式并不是windows开发的。它首先定义在OS/2的1.1版中。然后在Windows 3.0中（发布于1990）使用了OS/2位图格式，这时称之为DIB。Windows 3.0也包含了原始DIB格式的变体，并在Windows下成为标准。    
DIB首先作为一种文件格式，它的扩展名为.BMP，在极少情况下为.DIB。Windows应用程序使用的位图图像被当做DIB文件建立，并作为只读资源储存在程序的可执行文件中。   
程序能将DIB文件减去前14个字节加载连续的内存块中。这时就可以称它为**packed DIB（packed-DIB）格式的位图**。在Windows下执行的应用程序能使用packed DIB格式，通过Windows剪贴簿来交换图像或建立画刷。程序也可以完全存取DIB的内容并以任意方式修改DIB。   
程序也能在内存中建立自己的DIB然后把它们存入文件。**程序使用GDI函数呼叫就绘制**这些DIB内的图像，也能在程序中利用别的内存DIB直接设定和操作图素位。在内存中加载了DIB后，程序也能通过几个Windows API函数呼叫来使用DIB数据。   
### OS/2样式的DIB
先看一下在OS/2 1.1中出现的位图格式兼容的Windows DIB格式。   
> DIB文件四个部分：   
> 文件表头    
> 信息表头   
> RGB色彩对照表（不一定有）    
> 位图图素位    


可以把前两部分看成C的数据结构（文件表头和信息表头），第三部分看成数据结构的数组（RGB色彩对照表）。    
而在内存中的packed DIB格式（即程序能将DIB文件减去前14个字节加载连续的内存块中）有三个部分：    
> 信息表头   
> RGB色彩对照表（不一定有）   
> 位图图素位    


除了没有文件表头外（被程序删除了），其它与存储在文件里的DIB相同。   
而存在文件里的DIB文件，则是以如下结构的14个字节的文件表头开始：   
```c
typedef struct tagBITMAPFILEHEADER // bmfh(bitmap file header)       
{     
	WORD bfType; //signature word "BM" or 0x4D42    
	DWORD bfSize; //entire size of file    
	WORD bfReserved1; //must be zero    
	WORD bfReserved2; //must be zero    
	DWORD bfOffsetBits; //offset in file of DIB pixel bits    
}    
BITMAPFILEHEADER, * PBITMAPFILEHEADER ;     
```    
结构的长度为14字节，它以两个字母「BM」开头以指明是位图文件。这是一个WORD值0x4D42。紧跟在「BM」后的DWORD以字节为单位指出了包括文件表头在内的文件大小。下两个WORD字段设定为0。（在与DIB文件格式相似的鼠标光标文件内，这两个字段指出光标的「热点（hot spot）」）。结构还包含一个DWORD字段，它指出了文件中图素位开始位置的字节偏移量。此数值来自DIB信息表头中的信息，为了使用的方便提供在这里。   
在OS/2样式的DIB内，BITMAPFILEHEADER(文件表头）结构后紧跟BITMAPCOREHEADER（信息表头）结构，它提供了关于DIB图像的基本信息。紧缩的DIB（Packed DIB）开始于BITMAPCOREHEADER：    
```c
typedef struct tagBITMAPCOREHEADER // bmch(bitmap core header)/信息表头    
{    
	DWORD bcSize; //size of the structure = 12    
	WORD bcWidth; //width of image in pixels    
	WORD bcHeight; //height of image in pixels    
	WORD bcPlanes; //= 1    
	WORD bcBitCount; //bits per pixel (1, 4, 8, or 24)    
}    
BITMAPCOREHEADER, * PBITMAPCOREHEADER ;       
```   
**bcSize字段**指出了数据结构的大小，在这种情况下是12字节。**bcWidth和bcHeight**字段包含了以图素为单位的位图大小。这意味着一个DIB最大可能为65,535图素高和宽，但是我们几乎不会用到那么大的单位。**bcPlanes字段**的值始终是1。这个字段是我们在上一章中遇到的早期Windows GDI位图对象的残留物。**bcBitCount字段**指出了每图素的位数。对于OS/2样式的DIB，这可能是1、4、8或24。DIB图像中的颜色数等于1<<bmch.bcBitCount。   
于是，1代表2色DIB，4代表16色DIB，8代表256色DIB，24代表full-color DIB。 即每个图素的位数。   
对于前3种情况（1、4、8），BITMAPCOREHEADER后紧跟色彩对照表，24位DIB是没有色彩对照表的。**色彩对照表是一个3字节的RGBTRIPLE结构的数组，数组中的每个元素代表图像中的每种颜色。**    
```c
typedef struct tagRGBTRIPLE // rgbt/颜色对照表    
{    
	BYTE rgbtBlue; // 蓝色level   
	BYTE rgbtGreen; // 绿色level   
	BYTE rgbtRed; // 红色level   
}    
RGBTRIPLE ;   
```
**这样排列色彩对照表以便DIB中最重要的颜色首先显示**，我们将在下一章说明原因。     
WINGDI.H表头文件也定义了下面的结构：   
```c
typedef struct tagBITMAPCOREINFO //bmci   
{    
	BITMAPCOREHEADER bmciHeader; //core-header structure信息表头    
	RGBTRIPLE bmciColors[1]; //color table array颜色表       
}    
BITMAPCOREINFO, * PBITMAPCOREINFO ;    
```   
这个结构把信息表头与色彩对照表结合起来。虽然在这个结构中RGBTRIPLE结构的数量等于1，但在一般的DIB文件内RGBTRIPLE不会是1。根据每个图素的位数，色彩对照表的大小始终是（分别对应148）2、16或256个RGBTRIPLE结构。    
如果需要为8位DIB配置PBITMAPCOREINFO结构：  
```c
pbmci = malloc (sizeof (BITMAPCOREINFO) + 255 * sizeof (RGBTRIPLE)) ;    
```    
然后可以这样存取RGBTRIPLE结构：pbmci->bmciColors[i]    
因为RGBTRIPLE结构的长度是3字节，许多RGBTRIPLE结构可能在DIB中以奇数地址开始。然而，因为在DIB文件内始终有偶数个的RGBTRIPLE结构，所以紧跟在色彩对照表数组后的数据块总是以WORD地址边界开始。（ps，这段与内存相关的，目前还不太懂）    
紧跟在色彩对照表（24位DIB中是信息表头，没有色彩对照表）后的数据是图素位本身。
### 由下而上
像大多数位图格式一样，DIB中的图素位是以水平行组织的，用视讯显示器硬件的术语称作「扫描线」。行数等于BITMAPCOREHEADER结构的bcHeight字段。然而，与大多数位图格式不同的是，**DIB从图像的底行开始，往上表示图像**。    
我们说的“顶行”和“低行”是指虚拟图像的顶部和底部，但是我们说DIB文件的“第一行”是指代码的第一行，但是是虚拟图像的底部。总而言之，顶行和底行是按照虚拟图像来表示，而第一行和最后一行是根据代码来表示。     
至于为什么这样呢？    
> 简而言之，数学方法赢了。PM内的所有事物都以左下角为原点（包括窗口坐标），因此DIB也就有了那种方式。   
### DIB图素位
DIB文件的最后部分（在大多数情况下是DIB文件的主体）由实际的DIB的图素字节成。图素位是由从图像的底行开始并沿着图像向上增长的水平行组织的。    
DIB中的行数等于BITMAPCOREHEADER结构的bcHeight字段。每一行的图素数等于该结构的bcWidth字段。每个图素的位数可
以从bcBitCount字段取得，为1、4、8或24。    
以字节为单位的每行长度始终是4的倍数。行的长度可以计算为：    
```c
RowLength = 4 * ((bmch.bcWidth * bmch.bcBitCount + 31) / 32) ;     
RowLength = ((bmch.bcWidth * bmch.bcBitCount + 31) & ~31) >> 3 ;//或    
```    
图素数据的总字节数等于RowLength和bmch.bcHeight的乘积。   要了解图素编码的方式，让我们分别考虑四种情况。以下会做一个总结，细节可以参考P778。    
由于每个字节有8位，那么对于每图素1位的DIB，每个字节可以容纳8图素；对于每图素4位的DIB，每个字节可以容纳2图素；对于每图素8位的DIB，每个字节可以容纳1个图素；而对于每个图素24位的DIB，则三个字节对应一个图素。
### 扩展的windows DIB
### 真实检查
### DIB压缩
### 颜色掩码
### 第四版本的Header
### 第五版本的Header
### 显示DIB信息
参考DIBHEADS.C  