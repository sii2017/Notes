# Before Chapter 16 关于调色板内容
颜色调色板是一种机制，通过它**可以显示很宽范围的颜色而不需要使用大量的空间**。  
调色板显示方式只有每种像素4位和8位颜色深度两种，其中4位颜色深度已经不使用，我们只讨论每种像素8位的颜色深度。在这种色深下，每个像素可赋予一个从0到255的值，这个值充当一个索引，以访问有256个条目的数组，该数组即所谓的颜色调色板。在该数组中的每个条目，包含一个8位值以对应一种颜色的红、绿、蓝颜色强度。在效果上，这使每像素8位的色深可访问16777216种可能的颜色，**但只能同时显示其中的256种**。在显示位图的时候，视频硬解查看8位颜色值，运用该值作为索引访问256条目的颜色表。用指明的颜色表条目所存储的红、绿、蓝强度绘制像素。   
用每像素8位的颜色模式工作，有一个主要缺点是：**同时显示的所有位图必须用同一个调色板画出**。而用一个调色板画的位图在另一个使用其他调色板的设备上显示，会产生意想不到的结果（**不同设备上的调色板颜色，未必是一样的，颜色多达16777216但是只能同时显示256种**）。位图上的像素可以在当前景调色板上用最佳近似的适当颜色绘制出来，但这个过程很慢而且总会产生不合适的结果。可以对不同场景使用不同调色板，不过这也会降低效果。       
windows 所使用的调色板有两个不同种类：**系统调色板和逻辑调色板**。  
1 **系统调色板**是windows保留的全球通用调色板，包括一切可以显示的颜色。开头和末尾各有10个调色板条目为系统保留，包括20个用于绘制特殊用户界面元素的静态颜色，如windows标题栏、边界、三围用户界面元素。其余236个颜色可由程序设定。   
2 **逻辑调色板是由程序产生的，包含程序需要的颜色。当程序设置了它想要的颜色，windows调色板管理器将对逻辑调色板与当前的系统调色板进行合并，这是通过检查逻辑调色板每个条目，把它在已有系统调色板的条目上画出而实现的。如果一个颜色在两个调色板上都有这么做，如果没有找到匹配条目，就把逻辑调色板中的颜色放进系统调色板的第一个未经使用的条目。如果没有找到现成条目而且再没有未经使用的调色板条目，windows调色板管理器就用系统调色板中最近似的颜色来画。这个过程一直持续直到逻辑调色板与系统调色板中所有颜色合并为止。**   
在使用之前，必须把逻辑调色板选进设备环境(DC)。如果规定的设备环境认同一个激活的窗口，就把逻辑调色板当做前景调色板，windows调色板管理器将把系统调色板中所有非静态条目标注为未使用。这使逻辑调色板有潜力（可以）取代系统调色板中的非静态颜色。如果设备环境不认可激活的窗口，逻辑调色板就被当做背景调色板，只有在前景调色板合并后有剩余才能设置未经使用的调色板条目。   
注意：   
以前Windows只有16色或者256色的时候，系统有逻辑调色板和系统调色板，调色板存储了RGB表示的n种颜色，可以指定给画笔来绘图，功能和BMP里的色彩表是对应的。现在Windows的显示模式都是32位真彩色的，调色板已经没有用处，位图直接存储的是RGB值。   
以前的Windows绘图必须先把想要的颜色设置进调色板，现在不用了。调色板可以用来实现一些简单的动画。   
# 第十六章 调色盘管理器
如果硬件允许，本章就没有存在的必要。（**事实上我觉得2018年的今天本章也许确实没必要了，所以只对部分内容做笔记。**）   
尽管许多现代的显示卡提供24位颜色（也称「true color」或「数百万色」）或16位颜色（「增强色」或「数万种颜色」），一些显示卡－尤其是在便携式计算机上或高分辨率模式中－每个图素只允许8位。这意味着仅有256种颜色。    
很明显，要显示真实世界的图像，仅16种颜色是不够的，至少要使用数千或数百万种颜色，256种颜色位于中间状态。是的，用256种颜色来显示真实世界的图像足够了，但需要根据特定的图像来指定这些颜色。这意味着操作系统不能简单地选择「标准」系列的256种颜色，就希望它们对每个应用程序都是理想的颜色。   
这就是Windows调色盘管理器所要涉及的全部内容。**它用于指定程序在8位显示模式下执行时所需要的颜色。（显然现在的电脑无论什么情况下都不会使用8位显示模式了，但是还是学习一下吧。）**如果知道程序肯定不会在8位显示模式下执行，那么您也不需要使用调色盘管理器。不过，由于补充了位图的一些细节，所以本章还是包含重要信息的。    
## 使用调色盘
传统上讲，调色盘是画家用来混合颜色的板子。这个词也可以指画家在绘画过程中使用的所有颜色。**在计算机图形中，调色盘是在图形输出设备（例如视讯显示器）上可用的颜色范围。这个名词也可以指支持256色模式的显示卡上的对照表。**    
### 视频硬件
显示卡上的调色盘对照表运作过程如下图所示：   
![](https://github.com/sii2017/image/blob/master/%E8%B0%83%E8%89%B2%E7%9B%98%E5%8A%9F%E8%83%BD.png)   
在8位显示模式中，每个图素占8位。图素值查询包含256RGB值的对照表的地址。这些RGB值可以正好24位宽，或者小一点，通常是18位宽（即主要的红、绿和蓝各6位）。**每种颜色的值都输入到数字模拟转换器，以得到发送给监视器的红、绿和蓝三个模拟信号**。   
因为所有的应用程序都共享同一个视讯显示器并且可以同时执行，所以当一个应用程序使用了调色盘对照表可能会影响其它程序的使用。   
这时就需要使用Windows调色盘管理器（在Windows 3.0中提出）了。Windows保留了256种颜色中的20种，而允许应用程序修改其余的236种。（在某些情况下，应用程序最多可以改变256种颜色中的254种－只有黑色和白色除外－但这有一点麻烦）。Windows为系统保留的20种颜色（有时称为20种「静态」颜色）如下表所示。   
![](https://github.com/sii2017/image/blob/master/%E8%B0%83%E8%89%B2%E7%9B%98%E4%BA%8C%E5%8D%81%E9%9D%99%E6%80%81%E8%89%B2%E4%B8%8A.png)  
![](https://github.com/sii2017/image/blob/master/%E8%B0%83%E8%89%B2%E7%9B%98%E4%BA%8C%E5%8D%81%E9%9D%99%E6%80%81%E8%89%B2%E4%B8%8B.png)   
在256种颜色显示模式下执行时，由Windows维护系统调色盘，此调色盘与显示卡上的硬件调色盘对照表相同。   
内定的系统调色盘如上表所示。应用程序可以通过指定「逻辑调色盘」来修改其余236种颜色。如果有多个应用程序同时使用逻辑调色盘，那么Windows就给**活动窗口**最高优先权（活动窗口有高亮显示标题列，并且显示在其它所有窗口的前面）。   
要执行本章其它部分的程序，您可能需要将显示卡切换成256色模式。在桌面上单擎鼠标右键，从菜单中选择「属性」，然后选择「设定」页面标签。**（PS：现在的显卡一般都是32位的，其中24位达到三原色覆盖所有，另外八位增加了一些透明色，我似乎很难切换到8位256色）**   
### 显示灰阶
以下所示的GRAYS1程序没有使用Windows调色盘管理器，而尝试用正常显示的**65级种阶作为从黑到白的多种彩色的「来源」**。   
参考GRAYS1.C   
该程序用灰阶渐变色涂满整个显示窗口区域。在WM_PAINT消息处理期间，程序呼叫了65次FillRect函数，每次都使用不同灰阶建立的画刷。灰阶值是RGB值（0,0,0）、（4,4,4）、（8,8,8）等等，直到最后一个值（255,255,255）。最后一个值来自CreateSolidBrush函数中的min宏。  
如果在256色显示模式下执行该程序，将看到从黑到白的65种灰阶，而且它们几乎都用混色着色。纯颜色只有黑色、暗灰色（128,128,128）、亮灰色（192,192,192）和白色。其它颜色是混合了这些纯颜色的多位模式。  
如果我们在显示行或文字，而不是用这65种灰阶填充区域，Windows将不使用混色而只使用这四种纯色。如果我们正在显示位图，则图像将用20种标准Windows颜色近似。通常，Windows在位图中不使用混色。   
以下所示的GRAYS2程序用较少的外部程序代码验证了调色盘管理器中最重要的函数和消息。   
参考GRAYS2.C   
通常，使用调色盘管理器的第一步就是呼叫CreatePalette函数来建立逻辑调色盘。逻辑调色盘包含程序所需要的全部颜色－即236种颜色。  
GRAYS2程序在WM_CREATE消息处理期间处理此作业。它初始化LOGPALETTE（逻辑调色盘）结构的字段，并将这个结构的指针传递给CreatePalette函数。CreatePalette传回逻辑调色盘的句柄，并将此句柄储存在静态变量hPalette中。   
```c
typedef struct   
{   
	WORD palVersion;//通常设为0x0300，表示兼容Windows 3.0。  
	WORD palNumEntries;//调色盘表中的项目数   
	PALETTEENTRY palPalEntry[1];//是一个调色盘项目  
}   
LOGPALETTE, * PLOGPALETTE ;   
//上面的第三个参数的结构，每个PALETTEENTRY结构都定义了一个我们要在调色盘中使用的RGB颜色值。      
typedef struct  
{   
	BYTE peRed ;  
	BYTE peGreen ;   
	BYTE peBlue ;   
	BYTE peFlags ;   
}    
PALETTEENTRY, * PPALETTEENTRY ;   
```   
在初始的LOGPALETTE中只能默认包含一个PALETTEENTRY结构的数组。所以当我们需要65种颜色时，除了初始的那1个，还需要额外申请64个PALETTEENTRY结构的内存容量。GRAYS2程序需要65种灰阶，因此它为LOGPALETTE结构和64个附加的PALETTEENTRY结构配置了足够大的内存空间。   
初始化后程序将指向这个内存块的指针传递给CreatePalette，在一个静态变量中储存该调色盘句柄，然后释放内存。   
逻辑调色盘是GDI对象。程序应该删除它们建立的所有逻辑调色盘。因此在WM_DESTROY消息处理期间调用DeleteObject删除了逻辑调色盘。   
意逻辑调色盘是独立的设备内容。在真正使用之前，必须确保将其选进设备内容。**但是并不是使用SelectObject而是使用SelectPalette函数**。除了含有第三个参数以外，此函数与SelectObject函数相似。**通常第三个参数设为FALSE**。如果SelectPalette的第三个参数设为TRUE，那么调色盘将始终是「背景调色盘」，这意味着当其它所有程序都显现了各自的调色盘之后，该调色盘才可以获得仍位于系统调色盘中的一个未使用项目。   
在任何时候都只有一个逻辑调色盘能选进设备内容。   
通过将颜色映像到系统调色盘，RealizePalette函数使Windows在设备内容中「显现」逻辑调色盘，而系统调色盘是与显示卡实际的实际调色盘相对应（**这是针对十多年前并没有很多颜色的年底，而现在显卡普及并且通常皆为32位色，在编程的时候应该很少要手动调色盘了，猜测都直接使用系统调色盘/显卡调色盘**）。实际工作在此函数呼叫期间进行。Windows必须决定呼叫函数的窗口是活动的还是非活动的，并尽可能将系统调色盘已改变通知给其它窗口。   
在GRAYS1中，它用RGB宏来指定纯色画刷的颜色。RGB宏建构一个32位长整数（记作COLORREF值），其中高字节是0，3个低字节是红、绿和蓝的亮度。   
使用Windows调色盘管理器（系统原本的，而不是创建的逻辑键盘）的程序可以继续使用RGB颜色值来指定颜色。不过，这些RGB颜色值将**不能存取逻辑调色盘中的附加颜色**。它们的作用与没有使用调色盘管理器相同。要在逻辑调色盘中使用附加的颜色，就要用到PALETTERGB宏。除了COLORREF值的高字节设为2而不是0以外，「调色盘RGB」颜色与RGB颜色很相似。   
**下面是重要的规则：   
1 为了使用逻辑调色盘中的颜色，请用调色盘RGB值或调色盘索引来指定（我将简要讨论调色盘索引）。不要使用常规的RGB值。如果使用了常规的RGB值，您将得到一种标准颜色，而不是逻辑调色盘中的颜色。    
2 没有将调色盘选进设备内容时，不要使用调色盘RGB值或调色盘索引。   
3 尽管可以使用调色盘RGB值来指定逻辑调色盘中没有的颜色，但您还是要从逻辑调色盘获得颜色。**     
例如，在GRAYS2中处理WM_PAINT期间，当您选择并显现了逻辑调色盘之后，如果试图显示红色，则将显示灰阶。您必须用RGB颜色值来选择不在逻辑调色盘中的颜色。
### 调色盘信息
如果程序在逻辑调色盘中指定一种颜色，该颜色又是20种保留颜色之一，那么Windows将把逻辑调色盘项目映像给该颜色。另外，如果两个或多个应用程序都在它们的逻辑调色盘中指定了同一种颜色，那么这些应用程序将共享系统调色盘项目。程序可以通过将PALETTEENTRY结构的peFlags字段指定为常数PC_NOCOLLAPSE来忽略该内定状态（其余两个可能的标记是PC_EXPLICIT（用于显示系统调色盘）和PC_RESERVED（用于调色盘动画），将在本章的后面展示这两个标记）。   
Windows调色盘管理器含有两个发送给主窗口的消息。   
1 QM_QUERYNEWPALETTE消息。如果程序在窗口绘画时使用了**调色盘管理器**，则它必须处理该消息。GRAYS2中具体的做法是：程序获得设备内容句柄，并将调色盘选入设备内容中，调用函数RealizePalette（具现化，我理解为将设备内容中的逻辑调色盘合并到系统调色盘中），然后使窗口失效以产生WM_PAINT消息。如果显现了逻辑调色盘，则窗口消息处理程序从该消息传回TRUE，否则传回FALSE。    
2 WM_PALETTECHANGED消息。当系统调色盘改成与WM_QUERYNEWPALETTE消息的结果的颜色相同时，windows将发送WM_PALETTECHANGED消息给**当前活动的窗口**来启动并终止处理窗口链的所有主窗口。。这允许前台窗口有优先权。传递给窗口消息处理程序的wParam值是活动窗口的句柄。只有当wParam不等于程序的窗口句柄时（**即当前活动窗口不再是本程序的窗口时，系统调色板改变了**）（**这个消息是意味着调色板被改变了，如果是本程序的句柄则说明是我们自己改变的不用做多余的处理，而如果当前活动窗口句柄不是本程序，而是其他程序改变的调色板，那么就要做一些操作了，免得影响本程序窗口的颜色**），使用调色盘管理器的程序才会处理该消息。   
通常，在处理WM_PALETTECHANGED时，使用自订调色盘的任何程序都呼叫SelectPalette和RealizePalette。后续的窗口在消息处理期间呼叫RealizePalette时，**Windows首先检查逻辑调色盘中的RGB颜色是否与已加载到系统调色盘中的RGB颜色相匹配。如果两个程序需要相同的颜色，那么这两个程序就共同使用一个系统调色盘项目。否则，Windows检查未使用的系统调色盘项目。如果都已使用，则逻辑调色盘中的颜色从20种保留项目映像到最近的颜色。**   
**如果不关心程序非活动时显示区域的外观，那么您不必处理WM_PALETTECHANGED消息。否则，您有两个选择。**GRAYS2显示其中之一：在处理WM_QUERYNEWPALETTE消息时，它获得设备内容，选进调色盘，然后呼叫RealizePalette。这时就可以在处理WM_QUERYNEWPALETTE时呼叫InvalidateRect了。相反地，GRAYS2呼叫UpdateColors。这个函数通常比重新绘制窗口更有效，同时它改变窗口中图素的值来帮助保护以前的颜色。    
我们更多的使用前一种方法。   
### 调色盘索引方法
以下所示的GRAYS3程序与GRAYS2非常相似，只是在处理WM_PAINT期间使用了呼叫PALETTEINDEX的宏，而不是PALETTERGB。   
参考GRAYS3.C   
在GRAYS3中，逻辑调色盘有65个项目，用于这些项目的索引从0到64。所以就一个个用过去就好了。  
猜测索引应该对应的是**逻辑调色板**而不是**系统调色板**，应该是通过索引找到逻辑调色板中的颜色，再去系统调色板中找到对应的颜色。   
### 查询调色盘支持
在某些情况下，要使用调色盘管理器的Windows应用程序可能要先确定设备驱动程序是否支持它。这时，您可以呼叫GetDeviceCaps，并以视讯显示的设备内容句柄和PASTERCAPS作为参数。函数将传回由一系列旗标组成的整数。通过在传回值和常数RC_PALETTE之间执行位操作来检验支持的调色盘：   
```c
RC_PALETTE & GetDeviceCaps (hdc, RASTERCAPS)   
```   
如果此值非零，则视讯显示器设备驱动程序将支持调色盘操作。在这种情况之下，来自GetDeviceCaps的其它三个重要项目也是可用的。   
```c
//传回在显示卡上调色盘表的总尺寸。这与同时显示的颜色总数相同。因为调色盘管理器只用于每图素8位的视讯显示模式，所以此值将是256。   
GetDeviceCaps (hdc, SIZEPALETTE);   
//传回在调色盘表中的颜色数，该表是设备驱动程序为系统保留的，此值是20。不呼叫调色盘管理器，这些只是Windows应用程序在256色显示模式下使用的纯色。要使用其余的236种颜色，程序必须使用调色盘管理器函数。    
GetDeviceCaps (hdc, NUMRESERVED);    
//此值告诉您加载到硬件调色盘表的RGB颜色值分辨率（以位计）。这些是进入数字模拟转换器的位。某些视讯显示卡只使用6位ADC，所以该值是18。其余使用8位的ADC，所以值是24。   
GetDeviceCaps (hdc, COLORRES);   
```   
Windows程序注意颜色分辨率并因此采取一些动作是很有用的。   
例如，如果该颜色分辨率是18，那么程序将不可能要求到128种灰阶，因为只有64个离散的灰阶可用。要求到128种灰阶就不必用多余的项目来填充硬件调色盘表。
### 系统调色盘
Windows系统调色盘直接与显示卡上的硬件调色盘查询表相符。程序可以通过调用下面的函数来获得系统调色盘中的某些或全部的RGB项目：   
```c
GetSystemPaletteEntries (hdc, uStart, uNum, &pe);  
```   
只有显示卡模式支持调色盘操作时，该函数才能执行。第二个和第三个参数是无正负号整数，显示第一个调色盘项目的索引和调色盘项目数。最后一个参数是指向PALETTEENTRY型态的指针。   
然后可按下面的方法多次呼叫GetSystemPaletteEntries：  
```c
GetSystemPaletteEntries (hdc, i, 1, &pe) ;  
```    
其中的i从0到某个值，该值小于从GetDeviceCaps（带有SIZEPALETTE索引255）传回的值。   
或者，程序要获得所有的系统调色盘项目，可以通过定义指向PALETTEENTRY结构的指针，然后重新配置足够的内存块，以储存与调色盘大小指定同样多的PALETTEENTRY结构。   
GetSystemPaletteEntries函数允许我们检验硬件调色盘表。系统调色盘中的项目按图素值增加的顺序排列，这些值用于表示视讯显示缓冲区中的颜色。   
### 其他调色盘函数
之前说到，Windows程序能够改变系统调色盘，但只是间接改变，其步骤为：第一步建立逻辑调色盘，它基本上是程序要使用的RGB颜色值数组。CreatePalette函数不会导致系统调色盘或者显示卡调色盘表的任何变化。逻辑调色盘必须在任何事情发生之前就选进设备内容并显现。   
程序可以通过调用：   
```c
GetPaletteEntries (hPalette, uStart, uNum, &pe) ;   
```   
**来查询逻辑调色盘中的RGB颜色值。**可以按使用GetSystemPaletteEntries的方法来使用此函数。但是要注意，第一个参数是逻辑调色盘的句柄，而不是设备内容的句柄。    
建立逻辑调色盘以后，**改变其中的值**的相应函数是：   
```c
SetPaletteEntries (hPalette, uStart, uNum, &pe) ;
```   
调用此函数不引起系统调色盘的任何变化，即使目前调色盘选进了设备内容。此函数也不改变逻辑调色盘的尺寸。要**改变逻辑调色盘的尺寸**，需要使用ResizePalette。    
**下面的函数接受RGB颜色引用值作为最后的参数，并将索引传回给逻辑调色盘**，该逻辑调色盘与和它最接近的RGB颜色值相对应：   
```c
iIndex = GetNearestPaletteIndex (hPalette, cr) ;   
```   
第二个参数是COLORREF值。另外调用GetPaletteEntries就可以**获得逻辑调色盘中实际的RGB颜色值**。   
如果程序在8位显示模式下需要多于236种自定义颜色，则可以调用GetSystemPaletteUse。这允许程序设定254种自订颜色；系统仅保留黑色和白色。不过，程序仅在最大化充满全屏幕时才允许这样，而且它还将一些系统颜色设为黑色和白色，以便标题列和菜单等仍然可见。    
### 位映像操作问题
从第五章可以了解到，GDI允许使用不同的「绘画模式」或「位映像操作」来画线并填充区域。   
位映像操作就是在图素位上照着各个位的顺序进行操作。改变调色盘会影响到这些位映像操作。位映像操作的操作对象是图素位，**而这些图素位可能与实际颜色没有关联**（认为，实际颜色是在位映像操作之前的，而当进行位映像操作的时候是进行一些特殊操作的时候）。   
透过执行GRAYS2或GRAYS3程序，您自己就可以得出这个结论。调整尺寸时，拖动顶部或底部的边界穿过窗口，Windows利用反转背景图素位的位映像操作来显示拖动尺寸的边界，其目的是使拖动尺寸边界总是可见的。但在GRAYS2和GRAYS3程序中，您将看到各种随机变换的颜色，这些颜色恰好与对应于调色盘表中未使用的项目，那是反转显示图素位的结果。可视颜色没有反转－只有图素位反转了。   
正如在表16-1中所看到的一样，20种标准保留颜色位于系统调色盘的顶部和底部，以便位映像操作的结果仍然正常。然而一旦修改了调色盘，**尤其是替换了保留颜色**，那么颜色对象的位映像操作就变得没有意义了。   
唯一保证的是位映像操作将用黑色和白色运作。黑色是系统调色盘中的第一个项目（所有的图素位都设为0），而白色是最后的项目（所有的图素位都设为1）。这两个项目不能改变。如果需要预知在颜色对象上进行位映像操作的结果，则可以先获得系统调色盘表，然后查看不同图素位值的RGB颜色值。
### 查看系统调色盘
在Windows下执行的程序将处理逻辑调色盘，为使逻辑调色盘更好地服务于所有使用逻辑调色盘的程序，**Windows将在系统调色盘中设定颜色**。该系统调色盘复制了显示卡的硬件对照表内容。这样，查看系统调色盘有助于调适调色盘应用程序。   
由于对于这个问题有三种截然不同的处理方式，所以将展示三个程序，以显示系统调色盘的内容。
SYSPAL1程序，使用了前面所讲的GetSystemPaletteEntries函数。  
**参考SYSPAL1.C**  
与SYSPAL系列中的其它程序一样，除非带有SIZEPALETTE参数的GetDeviceCaps传回值为256，否则SYSPAL1不会执行。（现在的高端显卡并没有办法传回256，程序无法执行。尝试着屏蔽了这一个判断后，可以看到程序原本的目的似乎是用来传回系统调色盘中256个颜色的RGB值，当然我这里显示的都是0）   
在合并WM_PAINT消息处理期间，SYSPAL1呼叫GetSystemPaletteEntries，并用一个含256个PALETTEENTRY结构的数组作为参数。RGB值作为文字字符串显示在显示区域。程序执行时，注意20种保留颜色是RGB值列表中的前10个和后10个，这与表16-1所示相同。   
当SYSPAL1显示有用的信息时，它与实际看到的256种颜色不同。   
**参考SYSPAL2.C**   
SYSPAL2在WM_CREATE消息处理期间建立了逻辑调色盘。但是请注意：逻辑调色盘中所有的256个值都是从0到255的调色盘索引，并且peFlags字段是PC_EXPLICIT。该旗标是这样定义的：「逻辑调色盘项目的较低字组指定了一个硬件调色盘索引。此旗标允许应用程序显示硬件调色盘的内容。」该旗标就是专为我们要做的这件事情而设计的。   
在WM_PAINT消息处理期间，SYSPAL2将该调色盘选进设备内容并显现它。这不会引起系统调色盘的任何重组，而是允许程序使用PALETTEINDEX宏来指定系统调色盘中的颜色。按此方法，SYSPAL2显示了256个矩形。另外，当您执行该程序时，注意顶行和底行的前10种和后10种颜色是20种保留颜色，如表16-1所示。当您执行使用自己逻辑调色盘的程序时，显示就改变了。   
事实上，所有的GDI函数都直接或间接地指定颜色作为RGB值。在GDI内部，这将转换成与那个颜色相关的图素位。在某些显示模式中（例如，16位或24位颜色模式），这些转换是相当直接的。在其它显示模式中（4位或8位颜色），这可能涉及最接近颜色的搜索。
然而，有两个GDI函数让您直接指定图素位中的颜色。当然在这种方式中使用的这两个函数都与设备高度相关。它们太依赖设备了，以至于它们可以直接显示视讯显示卡上实际的调色盘对照表。这两个函数是BitBlt和StretchBlt。   
SYSPAL3程序显示了使用StretchBlt显示系统调色盘中颜色的方法。  
**参考SYSPAL3.C**    
在WM_CREATE消息处理期间，SYSPAL3使用CreateBitmap来建立16×16的每图素8位的位图。该函数的最后一个参数是包括数值0到255的256字节数组。这些是256种可能的图素位值。在处理WM_PAINT消息的程序中，程序将这个位图选进内存设备内容，用StretchBlt来显示并填充该显示区域。Windows仅将位图中的图素位传输到视讯显示器硬件，从而允许这些图素位存取调色盘对照表中的256个项目。程序的显示区域甚至不必使接收WM_PALETTECHANGED消息无效－对于对照表的任何修改都会立即影响到SYSPAL3的显示。   
PS:由于显卡的问题，SYSPAL123我都没法显示。