## 线程同步
### 临界区域
在多任务操作系统中，大多数的程序也似乎各自独立地在执行，但是可能会发生一些问题。例如，两个程序可能会需要同时从同一个文件中读或者对同一文件进行写。在这种情况下，操作系统提供了一种共享文件和记录上锁的技术来帮助解决这个问题。   
然而，在支持多线程的操作系统中，情况会变得混乱而且存在潜在的危险。两个或多个线程共享某些数据的情况并不罕见。例如，一个线程可以更新一个或者多个变量，而另一个线程可以使用这些变量。有时这会引发一个问题，有时又不会（记住操作系统将控制权从一个线程切换到另一个线程的操作，只能在机器码指令之间发生。如果**只是一个整数**被线程共享，那么对这个变量的改变通常发生在单个指令中，因此潜在的问题被最小化了）。  
假设线程共享几个变量，通常这几个变量或结构的字段在他们之间是一致的。操作系统在更新这些变量的程序中暂时中断了一个线程，那么这些线程将得到不一样的数据。   
因此数据的差异会导致某些程序上的冲突。我们所需要的是类似于红绿灯的程序写作技术，以帮助我们对线程交通进行协调和同步，这就是临界区域。大体上，**一个临界区域就是一块不可中断的程序代码**。   
有四个函数用于临界区域。要使用这些函数，您必须定义一个临界区域对象，这是一个型态为CRITICAL_SECTION的**全局变量**。例如：   
```c
CRITICAL_SECTION cs ;   
```   
这个CRITICAL_SECTION数据型态是一个结构。这个临界区域对象必须先被程序中的某个线程初始化，通过调用：   
```c
InitializeCriticalSection (&cs) ;   
```   
这样就建立了一个名为cs的临界区域对象。临界区域对象不能被移动或者复制，程序也不能修改该对象，但必须在逻辑上把它视为不透明的。概括的说，不要去动它甚至不要去看它，但是它是存在的。   
当临界区域对象被初始化之后，线程可以通过下面的调用进入临界区域：   
```c
EnterCriticalSection (&cs) ;   
```   
在这时候，调用上面函数的线程被认为“拥有”临界区域对象。两个线程不可以同时拥有同一个临界区域对象，因此，如果一个线程进入了临界区域，那么下一个使用同一临界区域对象呼叫EnterCriticalSection的线程将在函数呼叫中被暂停。只有当第一个线程通过下面的调用离开临界区域时，函数才会传回控制权（继续进入临界区域）：   
```c
LeaveCriticalSection (&cs);//离开临界区域   
```   
这时，在EnterCriticalSection呼叫中被停住的那个线程将拥有临界区域，其函数呼叫也将传回，允许线程继续执行。**在主线程中使用临界区域要小心，如果使用临界区域的副线程花费了大量时间，那么主线程将无法进行运行同样的时间。**       
当临界区域不再被程序所需要时，可以通过调用   
```c
DeleteCriticalSection (&cs) ;   
```   
将其删除，该函数释放所有被配置来维护此临界区域对象的系统资源。   
这种临界区域技术涉及「互斥」。在任何时刻，只有一个线程能拥有一个临界区域。因此，一个线程可以进入一个临界区域，设定一个结构的字段，然后退出临界区域。另一个使用该结构的线程在存取结构中的字段之前也要先进入该临界区域，然后再退出临界区域。   
我们可以定义多个临界区域对象。例如，如果一个程序有四个线程，而前两个线程共享一些数据，那么它们可以使用一个临界区域对象，而另外两个线程共享一些其它的数据，那么它们可以使用另一个临界区域对象。   
**临界区域的一个限制是它们只能用于在同一程序内的线程之间的协调。**但是在某些情况下，您需要协调两个不同程序对同一资源的共享（如共享内存等）。在此其况下不能使用临界区域，但是可以使用一种被称为「**互斥对象**（mutex object）」的技术。「mutex」是个合成字，代表「mutual exclusion（互斥）」，它在这里精确地表达了我们的目的。我们想防止一个程序的线程在更新数据或者使用共享内存与其它资源时被中断。