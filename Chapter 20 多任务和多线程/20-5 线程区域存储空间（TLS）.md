## 线程区域存储空间（TLS）
多线程程序中的全局变量（以及任何被配置的内存）被程序中的所有线程共享。一个函数中的局部静态变量也被使用函数的所有线程共享。。一个函数中的局部动态变量是唯一于各个线程的，因为局部动态变量是被储存在堆栈上，而每个线程有它自己的堆栈。    
对各个线程唯一的持续性储存空间是需要的。例如，我在本章前面提到过的C中的strtok函数要求这种型态的储存空间。不幸的是，C语言不支持这类储存空间。但是Windows中提供了四个函数，它们实作了一种技术来做到这一点，并且Microsoft对C的扩充语法也支持它，这就叫做线程区域储存空间。   
下面是API工作的方法（并不需要自己操作，仅仅是解释过程方法）：  
首先，定义一个包含需要唯一于线程的所有数据的结构，例如：   
```c
typedef struct  
{  
	int a ;   
	int b ;   
}   
DATA, * PDATA ;    
```   
主线程调用TlsAlloc获得一个索引值：   
```c   
dwTlsIndex = TlsAlloc () ;//创建索引   
```   
这个值可以储存在一个全局变量中或者通过参数结构传递给线程函数。  
线程函数首先为该数据结构配置内存，并使用上面所获得的索引值调用TlsSetValue：   
```c
TlsSetValue (dwTlsIndex, GlobalAlloc (GPTR, sizeof (DATA)) ;//绑定索引和指针   
```   
该函数将一个指针和某个线程及某个线程索引相关联。现在，任何需要使用这个指针的函数（包括最初的线程函数本身）都可以包含如下所示的程序代码：   
```c   
PDATA pdata ;   
...   
pdata = (PDATA) TlsGetValue (dwTlsIndex) ;//通过索引获取指针    
```    
现在函数可以设定或者使用pdata->a和pdata->b了。在**线程函数**终止以前，它释放配置的内存：   
```c   
GlobalFree (TlsGetValue (dwTlsIndex)) ;   
```    
当使用该数据的所有线程都终止之时，**主线程**将释放索引：   
```c
TlsFree (dwTlsIndex) ;   
```  
这个程序刚开始可能令人有些迷惑，因此如果能看一看如何实作线程区域储存空间可能会有帮助（我不知道Windows实际上是如何实作的，但下面的方案是可能的）。首先，TlsAlloc可能只是配置一块内存（长度为0）并传回一个索引值，即指向这块内存的一个指针。每次使用该索引呼叫TlsSetValue时，通过重新配置将内存块增大8个字节。在这8个字节中储存的是呼叫函数的线程ID（通过GetCurrentThreadId来获得）以及传递给TlsSetValue函数的指标。TlsSetValue简单地使用线程ID来搜寻操作系统管理的线程区域储存空间地址表，然后传回指标。TlsFree将释放内存块。所以您看，这可能是一件容易得可以由您自己来实作的事情。不过，既然已经有工具为您做好了这些工作，那也不错。   
Microsoft对C的扩充功能使这件工作更加容易。只要在要对每个线程都保留不同内容的变量前加上__declspec (thread)就好了。   
对于任何函数的外部静态变量，则为：   
```c
__declspec (thread) int iGlobal = 1 ;   
```   
对于函数内部的静态变量，则为：   
```c   
__declspec (thread) static int iLocal = 2 ;   
```   
在声明线程局部对象和变量时必须遵守下列准则：   
1 可以只将 thread 特性应用于类和数据声明和定义；thread 不能用于函数声明或定义。   
2 使用 thread 特性可能会影响 DLL 导入的延迟加载。   
3 在 XP 系统上，如果 DLL 使用 __declspec (thread) 数据并且通过 LoadLibrary 动态加载而成，则 thread 可能无法正常运行。   
4 只能在具有静态存储持续时间的数据项上指定 thread 特性。 这包括全局数据对象（static 和 extern）、本地静态对象和类的静态数据成员。 不能声明带 thread 特性的自动数据对象。   
5 必须为线程本地对象的声明和定义使用 thread 特性，无论声明和定义是在同一文件中还是单独的文件中发生。   
6 无法将 thread 特性用作类型修饰符。   
对该关键词做了测试，参考MULTI3.c