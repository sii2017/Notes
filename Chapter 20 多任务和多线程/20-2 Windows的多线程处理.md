## Windows的多线程处理
建立新的线程的API函数是CreateThread，它的语法如下：   
```c
hThread= CreateThread (&security_attributes, dwStackSize, ThreadProc, pParam, dwFlags, &idThread);   
```   
第一个参数是指向SECURITY_ATTRIBUTES型态的结构的指针。在Windows 98中忽略该参数。在Windows NT中，它被设为NULL。    
第二个参数是用于新线程的初始堆栈大小，默认值为0。**在任何情况下，Windows根据需要动态延长堆栈的大小**。   
第三个参数是指向线程函数的指标。函数名称没有限制，但是必须以下列形式声明：    
```c
DWORD WINAPI ThreadProc (PVOID pParam);   
```   
第四个参数为传递给ThreadProc的参数。这样主线程和从属线程就可以共享数据。   
第五个参数通常为0，但当建立的线程不马上执行时为旗标CREATE_SUSPENDED。线程将暂停直到呼叫ResumeThread来恢复线程的执行为止。    
第六个参数是一个指针，指向接受执行绪ID值的变量。   
大多数Windows程序写作者喜欢用在PROCESS.H表头文件中声明的C执行时期链接库函数_beginthread来替代CreateThread。它的语法如下：   
```c
hThread = _beginthread (ThreadProc, uiStackSize, pParam) ;   
```    
它更简单，对于大多数应用程序很完美，这个线程函数的语法为：   
```c    
void __cdecl ThreadProc (void * pParam) ;   
```   
### 再论随机矩形
RNDRCTMT是第五章里的RANDRECT程序的多线程版本。   
参考RNDRCTMT.C   
窗口消息处理程序以最容易的方法调用_beginthread－简单地以线程函数的地址（称为Thread）作为第一个参数，其它参数使用0，线程函数传回VOID并有一个参数，该参数是一个指向VOID的指标。在RNDRCTMT中的Thread函数不使用这个参数。  
在调用了_beginthread函数之后，线程函数（以及该线程函数可能呼叫的其它任何函数）中的程序代码和程序中的其它程序代码**同时执行**。两个或者多个执行绪使用一个程序中的同一函数，在这种情况下，动态区域变量（储存在堆栈上）对每个执行绪是唯一的。对程序中的所有执行绪来说，所有的静态变量都是一样的。因此设定cxClient和cyClient为全局变量来给线程函数使用。    
有时您需要唯一于各个线程的持续储存性数据。通常，这种数据是静态变量，但在Windows 98中，可以使用「线程区域储存空间」，我将在本章后面进行讨论。     
### 程序设计竞赛的问题
1986年10月3日，Microsoft举行了为期一天，针对计算机杂志出版社的技术编辑和作者的简短的记者招待会，来讨论他们当时的一组语言产品，包括他们的第一个交谈式开发环境，QuickBASIC 2.0。当时，Windows 1.0出现还不到一年，但是没有人知道我们什么时候能得到与该环境类似的东西（这花了好几年）。这一事件与众不同的部分原因是由于Microsoft的公关人员所举办的「Storm the Gates」程序设计竞赛。Bill Gates使用QuickBASIC 2.0，而计算机出版社的人员可以使用他们选择的任何语言产品。    
竞赛的问题是从公众提出的题目中挑选出来的（挑选那些需要写大约半小时程序来解决的问题），问题如下：    
> 建立一个包含四个窗口的多任务仿真程序。第一个窗口必须显示一系列的递增数，第二个必须显示一系列的递增质数，而第三个必须显示Fibonacci数列（Fibonacci数列以数字0和1开始，后头每一个数都是其前两个数的和－即0、1、1、2、3、5、8等等）。这三个窗口应该在数字达到窗口底部时或者进行滚动，或者自行清除窗口内容。第四个窗口必须显示任意半径的圆，而程序必须在按下一个Escape键时终止。   
  
当然，在1986年10月，在DOS下执行的这样一个程序最多只能是模拟多任务而已。   
参加这次竞赛的大多数人编写了一个程序来将屏幕分为四个区域，程序中包含一个循环，依次更新每个窗口，然后检查是否按下了Escape键。如同DOS环境下的传统习惯，程序占用了百分之百的CPU处理时间。   
如果在Windows 1.0中写程序，那么结果将是类似程序MULTI1的结果。我说「类似」，是因为我编写的程序是32位的，但程序结构和相当多的程序代码－除了变量和函数参数定义以及Unicode支持－都是相同的。     
参考MULTI1.C   
### 多线程解决方案
参考MULTI2.C
### 有问题嘛？
### Sleep的好处