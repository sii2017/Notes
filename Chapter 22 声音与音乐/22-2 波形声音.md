## 波形声音
波形声音是最常用的Windows多媒体特性。**波形声音设备可以通过麦克风捕捉声音，并将其转换为数值**，然后把它们储存到内存或者磁盘上的波形文件中，波形文件的扩展名是.WAV。这样，声音就可以播放了。
### 声音与波形
在接触波形声音API之前，具备一些预备知识很重要，这些知识包括物理学、听觉以及声音进出计算机的程序。   
声音就是振动。当声音改变了鼓膜上空气的压力时，我们就感觉到了声音。**麦克风可以感应这些振动，并且将它们转换为电流。同样，电流再经过放大器和扩音器，就又变成了声音。**传统上，声音以模拟方式储存（例如录音磁带和唱片），这些振动储存在磁气脉冲或者轮廓凹槽中。当声音转换为电流时，就可以用随时间振动的波形来表示。振动最自然的形式可以用正弦波表示。   
正弦波有两个参数－振幅（也就是一个周期中的最大振幅）和频率。我们已知振幅就是音量，频率就是音调。一般来说人耳可感受的正弦波的范围是从20Hz（每秒周期）的低频声音到20,000Hz的高频声，但随着年龄的增长，对高频声音的感受能力会逐年退化。    
人感受频率的能力与频率是对数关系而不是线性关系。也就是说，我们感受20Hz到40Hz的频率变化与感受40Hz到80Hz的频率变化是一样的。在音乐中，这种加倍的频率定义为八度音阶。因此，人耳可感觉到大约10个八度音阶的声音。钢琴的范围是从27.5 Hz到4186 Hz之间，略小于7个八度音阶。   
虽然正弦波代表了振动的大多数自然形式，但纯正弦波很少在现实生活中单独出现，而且，纯正弦波并不动听。大多数声音都很复杂。   
任何周期的波形（即，一个循环波形）可以分解成多个正弦波，这些正弦波的频率都是整倍数。这就是所谓的Fourier级数，它以法国数学家和物理学家Jean Baptiste Joseph Fourier（1768-1830）的名字命名。    
周期的频率是基础。级数中其它正弦波的频率是基础频率的2倍、3倍、4倍（等等）。这些频率的声音称为泛音。基础频率也称作一级谐波。第一泛音是二级谐波，以此类推。    
正弦波谐波的相对强度给每个周期的波形唯一的声音。这就是「音质」，它使得喇叭吹出喇叭声，钢琴弹出钢琴声。    
人们一度认为电子合成乐器仅仅需要将声音分解成谐波并且与多个正弦波重组即可。不过，事实证明现实世界中的声音并不是这么简单。代表现实世界中声音的波形都没有严格的周期。乐器之间谐波的相对强度是不同的，并且谐波也随着每个音符的演奏时间改变。特别是乐器演奏音符的开始位置－我们称作起奏（attack）－相当复杂，但这个位置又对我们感受音质至关重要。     
由于近年来数字储存能力的提高，我们可以将声音直接以数字形式储存而不用复杂的重组。   
### 脉冲编码调制
计算机处理的是数值，因此要使声音进入计算机，就必须设计一种能将声音与数字信号相互转换的机制。    
不压缩数据就完成此功能的最常用方法称作「脉冲编码调制」（PCM：pulse code modulation）。PCM可用在光盘、数字式录音磁带以及Windows中。**脉冲编码调制其实只是一种概念上很简单的处理步骤的奇怪代名词而已**。   
利用脉冲编码调制，波形可以按固定的周期频率取样，其频率通常是每秒几万次。对于每个样本都测量其波形的振幅。完成将振幅转换成数字信号工作的硬件是模拟数字转换器（ADC：analog-to-digital converter）。类似地，通过数字模拟转换器（DAC：digital-to-analog converter）可将数字信号转换回波形电子信号。**但这样转换得到的波形与输入的并不完全相同。**合成的波形具有由高频组成的尖锐边缘。因此，播放硬件通常在数字模拟转换器后还包括一个低通滤波器。此滤波器滤掉高频，并使合成后的波形更平滑。在输入端，低通滤波器位于ADC前面。    
脉冲编码调制有两个参数：**取样频率**，即每秒内测量波形振幅的次数；**样本大小**，即用于储存振幅级的位数。    
取样频率越高，样本大小越大，原始声音的复制品才更好。   
不过，存在一个提高取样频率和样本大小的极点，超过这个极点也就超过了人类分辨声音的极限。    
另外，如果取样频率和样本大小过低，将导致不能精确地复制音乐以及其它声音。     
### 取样频率
取样频率决定声音可被数字化和储存的最大频率。并且，**取样频率必须是样本声音最高频率的两倍**。这就是「Nyquist频率（Nyquist Frequency）」，以30年代研究取样程序的工程师Harry Nyquist的名字命名。    
声音CD中使用的取样频率是每秒44,100个样本，或者称为44.1kHz。这个特有的数值是这样产生的：    
人耳可听到最高20kHz的声音，因此要拦截人能听到的整个声音范围，就需要40kHz的取样频率。然而，由于低通滤波器具有频率下滑效应，所以取样频率应该再高出大约百分之十才行。现在，取样频率就达到了44kHz。这时，我们要与视讯同时记录数字声音，于是取样频率就应该是美国、欧洲电视显示格速率的整数倍，这两种视讯格速率分别是30Hz和25Hz。这就使取样频率升高到了44.1kHz。     
取样频率为44.1kHz的光盘会产生大量的数据，这对于一些应用程序来说实在是太多了，例如对于录制声音而不是录制音乐时就是这样。把取样频率减半到22.05 kHz，可由一个10 kHz的泛音来简化复制声音的上半部分。再将其减半到11.025 kHz就向我们提供了5 kHz频率范围。44.1 kHz、22.05 kHz和11.025 kHz的取样频率，以及8 kHz都是波形声音设备普遍支持的标准。     
因为钢琴的最高频率为4186 Hz，所以您可能会认为给钢琴录音时，11.025 kHz的取样频率就足够了。但4186 Hz只是钢琴最高的基础频率而已，滤掉大于5000Hz的所有正弦波将减少可被复制的泛音，而这样将不能精确地捕捉和复制钢琴的声音。    
### 样本大小
脉冲编码调制的第二个参数**样本大小**是按位计算的。样本大小决定了可供录制和播放的最低音与最高音之间的区别。这就是通常所说的动态范围。   
声音强度是波形振幅的平方（即每个正弦波一个周期中最大振幅的合成）。与频率一样，人对声音强度的感受也呈对数变化。    
两个声音在强度上的区别是以贝尔（以电话发明人Alexander Graham Bell的名字命名）和分贝（dB）为单位进行测量的。1贝尔在声音强度上呈10倍增加。1dB就是以相同的乘法步骤成为1贝尔的十分之一。由此，1dB可增加声音强度的1.26倍（10的10次方根），或者增加波形振幅的1.12倍（10的20次方根）。1分贝是耳朵可感觉出的声强的最小变化。从开始能听到的声音极限到让人感到疼痛的声音极限之间的声强差大约是100 dB。（？？？？）     
Windows同时支持8位和16位的样本大小。（现在win10难道支持64位的吗？）储存8位的样本时，样本以无正负号字节处理，静音将储存为一个值为0x80的字符串。16位的样本以带正负号整数处理，这时静音将储存为一个值为0的字符串。   
要计算未压缩声音所需的储存空间，可用以秒为单位的声音持续时间乘以取样频率。如果用16位样本而不是8位样本，则将其加倍，如果是录制立体声则再加倍。例如，1小时的CD声音（或者是在每个立体声样本占2字节、每秒44 ,100个样本的速度下进行3 600秒）需要635MB，这快要接近一张CD-ROM的储存量了。    
ps：现在都进行压缩了，甚至可能还有各种优化，这种不压缩的原始声源可能意义不大。    
### 在软件中产生正弦波
以下将使用低阶的波形声音API（即，前缀是waveOut的函数）来建立一个称作SINEWAVE的声音正弦波生成器。**此程序以1Hz的增量来生成从20Hz（人可感觉的最低值）到5,000Hz（与人感觉的最高值相差两个八度音阶）的正弦波。**    
第一次考虑这个问题时，大概会认为将一个周期的正弦波分成若干固定数量的样本－例如360个－才合理。对于20Hz的正弦波，每秒输出7,200个样本。对于200Hz的正弦波，每秒则要输出72,000个样本。这有可能实作，但实际上却不能这么做。对于5,000Hz的正弦波，就需要每秒输出1,800,000个样本，这的确会增大DAC的负担！更重要的是，对于更高的频率，这种作法会比实际需要的精确度还高。   
就脉冲编码调制而言，取样频率是个常数。假定取样频率是SINEWAVE程序中使用的11,025Hz。如果要生成一个2,756.25Hz（确切地说是四分之一的取样频率）的正弦波，则正弦波的每个周期就有4个样本。对于25Hz的正弦波，每个周期就有441个样本。通常，每周期的样本数等于取样频率除以要得到的正弦波频率。一旦知道了每周期的样本数，用2π弧度除以此数，然后用sin函数来获得每周期的样本。然后再反复对一个周期进行取样，从而建立一个连续的波形。    
但是每周期的样本数可能带有小数，因此在使用时这种方法并不是很好。每个周期的尾部都会有间断。   
使它正常工作的关键是保留一个静态的「相位角」变量。此角初始化为0。第一个样本是0度正弦。随后，相位角增加一个值，该值等于2π乘以频率再除以取样频率。用此相位角作为第二个样本，并且按此方法继续。一旦相位角超过2π弧度，则减去2π弧度，而不要把相位角再初始化为0。    
例如，假定要用11,025Hz的取样频率来生成1,000Hz的正弦波（取样频率除以要得到的正弦波频率），即每周期有大约11个样本。为便于理解，此处相位角按度数给出－大约前一个半周期的相位角是：0、32.65、65.31、97.96、130.61、163.27、195.92、228.57、261.22、293.88、326.53、359.18、31.84、64.49、97.14、129.80、162.45、195.10，以此类推。存入缓冲区的波形数据是这些角度的正弦值，并已缩放到每样本的位数。为后来的缓冲区建立数据时，可继续增加最后的相位角，而不要将它初始化为0。    
**参考SINEWAVE**    
SINEWAVE的窗口包含三个控件：一个用于选择频率的水平滚动条，一个用于显示目前所选频率的静态文字区域，以及一个标记为「Turn On」的按钮。按下此按钮后，您将从连结声卡的扩音器中听到正弦波的声音，同时按钮上的文字将变成「Turn Off」。用键盘或者鼠标移动滚动条可以改变频率。要关闭声音，可以再次按下按钮。    
SINEWAVE程序代码初始化滚动条，以便频率在WM_INITDIALOG消息处理期间最低是20Hz，最高是5000Hz。初始化时，滚动条设定为440 Hz。用音乐术语来说就是中音上面的A，它在管弦乐队演奏时用来调音。DlgProc在接收WM_HSCROLL消息处理期间改变静态变量iFreq。注意，Page Left和Page Right将导致DlgProc增加或者减少一个八度音阶。    
当DlgProc从按钮收到一个WM_COMMAND消息时，它首先配置4个内存块－2个用于WAVEHDR结构。另两个用于缓冲区储存波形数据，我们将这两个缓冲区称为pBuffer1和pBuffer2。   
通过调用waveOutOpen函数，SINEWAVE**打开波形声音设备以便输出**，waveOutOpen函数使用下面的参数：    
```c
waveOutOpen (&hWaveOut, wDeviceID, &waveformat, dwCallBack, dwCallBackData, dwFlags) ;    
```    
第一个参数设定为指向HWAVEOUT（handle to waveform audio output：波形声音输出句柄）型态的变量。从函数传回后，此变量将被设定为一个句柄，后面的波形输出调用中将使用该句柄。    
waveOutOpen的第二个参数是设备ID。它允许函数可以在安装多个声卡的机器上使用。参数的范围在0到系统所安装的波形输出设备数之间。（调用waveOutGetNumDevs可以获得波形输出设备数，而调用waveOutGetDevCaps可以找出每个波形输出设备。）可以用常数WAVE_MAPPER（定义为-1）来选择设备，该设备在「控制台」的「多媒体」中「音效」页面卷标里的「喜欢使用的设备」中指定。另外，如果首选设备不能满足需要，而其它设备可以，那么系统将选择其它设备。    
第三个参数是指向WAVEFORMATEX结构的指针。    
```c
typedef struct waveformat_tag   
{     
	WORD wFormatTag ; // waveform format = WAVE_FORMAT_PCM     
	WORD nChannels ; // number of channels = 1 or 2   
	DWORD nSamplesPerSec ; // sample rate   
	DWORD nAvgBytesPerSec ; // bytes per second   
	WORD nBlockAlign ; // block alignment    
	WORD wBitsPerSample ; // bits per samples = 8 or 16    
	WORD cbSize ; // 0 for PCM    
}      
WAVEFORMATEX, * PWAVEFORMATEX ;    
```    
可用此结构指定取样频率（nSamplesPerSec）和取样精确度（nBitsPerSample），以及选择单声道或立体声（nChannels）。结构中有些信息看起来是多余的，但该结构也可用于非PCM的取样方式。在非PCM取样方式下，此结构的最后一个字段设定为非0值，并带有其它信息。    
对于PCM取样方式，nBlockAlign字段设定为nChannels乘以wBitsPerSample再除以8所得到的数值，它表示每次取样的总字节数。nAvgBytesPerSec字段设定为nSamplesPerSec和nBlockAlign的乘积。    
第四个参数是窗口句柄或指向动态链接库中callback函数的指标，用来表示接收波形输出消息的窗口或者callback函数。使用callback函数时，可在第五个参数中指定程序定义的数据。dwFlags参数可设为CALLBACK_WINDOW或CALLBACK_FUNCTION，以表示第四个参数的型态。也可一用WAVE_FORMAT_QUERY标记来检查能否打开设备（实际上并不打开它）。还有其它几个标记可用。     
SINEWAVE初始化WAVEFORMATEX结构的字段，并调用waveOutOpen函数：    
```c
waveOutOpen ( &hWaveOut, WAVE_MAPPER, &waveformat,
(DWORD) hwnd, 0, CALLBACK_WINDOW)   
```    
如果呼叫成功，则waveOutOpen函数传回MMSYSERR_NOERROR（定义为0），否则传回非0的错误代码。如果waveOutOpen的传回值非0，则SINEWAVE清除窗口，并显示一个标识错误的消息框。    
**设备打开后**，SINEWAVE继续初始化两个WAVEHDR结构的字段，这两个结构用于在API中传递缓冲。WAVEHDR定义如下：    
```c
typedef struct wavehdr_tag    
{   
	LPSTR lpData; // pointer to data buffer   
	DWORD dwBufferLength; // length of data buffer   
	DWORD dwBytesRecorded; // used for recorded    
	DWORD dwUser; // for program use    
	DWORD dwFlags; // flags    
	DWORD dwLoops; // number of repetitions   
	struct wavehdr_tag FAR *lpNext; // reserved   
	DWORD reserved; // reserved    
}   
WAVEHDR, *PWAVEHDR ;       
```    
SINEWAVE将lpData字段设定为包含数据的缓冲区地址，dwBufferLength字段设定为此缓冲区的大小，dwLoops字段设定为1，其它字段都设定为0或NULL。如果要重复循环播放声音，可设定dwFlags和dwLoops字段。     
SINEWAVE下一步为两个信息表头调用waveOutPrepareHeader函数，**以防止结构和缓冲区与磁盘发生数据交换**。    
**到此为止，所有的这些准备都是响应单击开启声音的按钮**。但在程序的消息队列里已经有一个消息在等待响应。**因为我们已经在函数waveOutOpen中指定要用一个窗口消息处理程序来接收波形输出消息，所以waveOutOpen函数向程序的消息队列发送了MM_WOM_OPEN消息**，wParam消息参数设定为波形输出句柄。要处理MM_WOM_OPEN消息，SINEWAVE调用FillBuffer函数两次，并用正弦波形数据填充pBuffer缓冲区。然后SINEWAVE把两个WAVEHDR结构传送给waveOutWrite，此函数将数据传送到波形输出硬件，才真正开始播放声音。     
当波形硬件播放完waveOutWrite函数传送来的数据后，就向窗口发送MM_WOM_DONE消息，其中wParam参数是波形输出句柄，lParam是指向WAVEHDR结构的指针。SINEWAVE在处理此消息时，将计算缓冲区的新数据，并呼叫waveOutWrite来重新提交缓冲区。    
> 代码中调用了两次waveOutWrite。这是使用的「双缓冲」技术避免了声音的不连续。编写SINEWAVE程序时也可以只用一个WAVEHDR结构和一个缓冲区。不过，这样在播放完数据后将会有很短暂的停顿，以等待程序处理MM_WOM_DONE消息来提交新的缓冲区。   

当使用者单击「Turn Off」按钮关闭声音时，DlgProc接收到另一个WM_COMMAND消息。对此消息，DlgProc把bShutOff变量设定为TRUE，并调用waveOutReset函数。此函数停止处理声音并发送一条MM_WOM_DONE消息。SINEWAVE通过调用waveOutClose来处理MM_WOM_DONE，产生一条MM_WOM_CLOSE消息。处理MM_WOM_CLOSE通常包括清除程序。SINEWAVE为两个WAVEHDR结构而调用waveOutUnprepareHeader（清除由waveOutPrepareHeader完成的准备），释放所有的内存块并把按钮上的文字改回「Turn On」。    
最后总调用EndDialog来结束程序。
### 数位录音机  
Windows提供了一个称为「录音程序」来录制和播放数字声音。程序RECORD1不如「录音程序」完善，因为它不含有任何文件I/O，也不允许声音编辑。然而，这个程序显示了使用低阶波形声音API来录制和回放声音的基本方法。    
**参考RECORD1**     
RECORD.RC和RESOURCE.H文件也在RECORD2和RECORD3程序中使用。     
RECORD1窗口有8个按钮。第一次执行RECORD1时，只有「Record」按钮有效。按下「Record」后，就开始录音，这时「Record」按钮无效，而「End」按钮有效。按下「End」可停止录音。这时，「Play」、「 Reverse」、「 Repeat」和「Speedup」也都有效，选择任一个按钮都可重放声音：「Play」表示正常播放；「Reverse」表示反向播放；「Repeat」表示无限的重复播放（好像循环录音带）；「Speedup」以正常速度的两倍来播放。要停止播放，您可以选择「End」按钮，而按下「Pause」按钮可停止播放。按下后，「Pause」按钮将变为「Resume」按钮，用于继续播放声音。如果要录制另一段声音，新录制的声音将替换内存里现有的声音。         
RECORD1用了许多快捷方式来简化程序代码。1，如果安装了多个波形声音硬设备，则RECORD1只使用内定设备。2，程序只能按标准的11.025 kHz的取样频率和8位的取样精确度来录音和放音，而不管设备能否提供更高的取样频率和取样精确度。    
唯一的例外是加速功能，加速时RECORD1按22.050kHz的取样频率播放声音，这样不仅播放速度提高了一倍，而且频率也提高了一个音阶。   
录制声音既包括为输入而打开波形声音硬件，还包括将缓冲区传递给API，以便接收声音数据。    
RECORD1设有几个内存块。其中三个很小，在DlgProc的WM_INITDIALOG消息处理期间进行配置。程序配置两个WAVEHDR结构，分别由指针pWaveHdr1和pWaveHdr2指向。这两个结构用于将缓冲区传递给波形API。pSaveBuffer指针指向储存整个录音的缓冲区，最初配置时只有一个字节。然后，随着录音的进行，该缓冲区不断增大，以适应所有的声音数据（如果录音时间过长，则RECORD1能够在录制程序中及时发现内存溢出，并允许您重放成功储存的声音）。指针pBuffer1和pBuffer2指向的另外两个内存块，大小是16K，它们在记录接收的声音数据时配置。录音结束后释放这些内存块。   
8个按钮中的每一个都向REPORT1窗口的对话程序DlgProc产生WM_COMMAND消息。**最初只有「Record」按钮有效，按下将产生WM_COMMAND消息**，其中wParam参数等于IDC_RECORD_BEG。为处理这个消息，RECORD1配置两个16K的缓冲区来接收声音数据，初始化WAVEFORMATEX结构的字段，并将此结构传递给waveInOpen函数，然后设定两个WAVEHDR结构。    
**waveInOpen函数产生一条MM_WIM_OPEN消息**。在此消息处理期间，RECORD1把储存缓冲区的大小缩减到1个字节，以准备接收数据（当然，第一次录音时，储存缓冲区的大小就是1个字节，但以后录制时，就可能大多了）。在MM_WIM_OPEN消息处理期间，RECORD1也将适当的按钮设定为有效和无效。然后，程序用waveInAddBuffer把两个WAVEHDR结构和缓冲区传送给API。这时会设定某些标记，然后呼叫waveInStart开始录音。    
采用11.025kHz的取样频率和8位的取样精确度时，16K的缓冲区可储存大约1.5秒的声音。这时，RECORD1接收MM_WIM_DATA消息。在响应此消息处理期间，程序将根据变量dwDataLength和WAVEHDR结构中的字段dwBytesRecorded对缓冲区重新配置。如果配置失败，RECORD1呼叫waveInClose来停止录音。   
如果重新配置成功，则RECORD1把16K缓冲区里的数据复制到储存缓冲区，然后再次呼叫waveInAddBuffer。此程序将持续到RECORD1用完储存缓冲区的内存，或使用者按下「End」按钮为止。   
「End」按钮产生WM_COMMAND消息，其中wParam等于IDC_RECORD_END。处理这个消息很简单，RECORD1把bEnding标记设定为TRUE并呼叫waveInReset。waveInReset函数使录音停止，并产生MM_WIM_DATA消息，该消息含有部分填充的缓冲区。除了呼叫waveInClose来关闭波形输入设备外，RECORD1对这个消息正常响应。   
waveInClose产生MM_WIM_CLOSE消息。RECORD1响应此消息时，释放16K输入缓冲区，并使相应的按钮有效或无效。尤其是，当储存缓冲区里存有数据（除非第一次配置就失败，否则一般都含有数据）时，播放按钮将有效。   
录音以后，储存缓冲区里将含有这些声音数据。当使用者选择「Play」按钮时，DlgProc就接收一个WM_COMMAND消息，其中wParam等于IDC_PLAY_BEG。响应时，程序将初始化WAVEFORMATEX结构的字段，并呼叫waveOutOpen。    
waveOutOpen呼叫再次产生MM_WOM_OPEN消息，在此消息处理期间，RECORD1把相应的按钮设为有效或无效（只允许使用「Pause」和「End」），用储存缓冲区来初始化WAVEHDR结构的字段，呼叫waveOutPrepareHeader来准备要播放的声音，然后呼叫waveOutWrite开始播放。      
一般情况下，直到播放完储存缓冲区里的所有数据才停止。这时产生MM_WOM_DONE 消息。如果还有缓冲区要播放，则程序会在这时将它们传递给API。由于RECORD1只播放一个大缓冲区，因此程序不再简单地准备标题，而是呼叫waveOutClose。waveOutClose函数产生MM_WOM_CLOSE消息。在此消息处理期间，RECORD1使相应的按钮有效或无效，并允许声音再次播放或者录制新声音。   
程序中还有一个**「End」**按钮，利用此按钮，使用者可以在播放完储存缓冲区之前的任何时刻停止播放。「End」按钮产生一个WM_COMMAND消息，其中wParam等于IDC_PLAY_END，响应时，程序呼叫waveOutReset，此函数产生一条正常处理的MM_WOM_DONE消息。    
RECORD1的窗口中还包括一个**「Pause」**按钮。处理此按钮很简单：第一次按时下，RECORD1呼叫waveOutPause来暂停播放，并将按钮上的文字改为「Resume」。按下「Resume」按钮MM_WIM_DATA时，通过呼叫waveOutRestart来继续播放。   
窗口中还包括另外三个按钮：**「Reverse」、「Repeat」和「Speedup」**。这些按钮都产生WM_COMMAND消息，其中wParam的值分别等于IDC_PLAY_REV、IDC_PLAY_REP和IDC_PLAY_SPEED。   
倒放声音就是把储存缓冲区里的数据按字节顺序反向，然后再正常播放。**RECORD1中有一个称为ReverseMemory的小函数使字节反向**。在WM_COMMAND消息处理期间，程序在播放块之前呼叫此函数，并在MM_WOM_CLOSE消息的后期再次呼叫此函数，以便将其恢复到正常状态。    
「Repeat」按钮将往复不停地播放声音。由于API支持重复播放声音，所以这并不复杂。只要将WAVEHDR结构的dwLoops字段设为重复次数，将dwFlags字段设为WHDR_BEGINLOOP和WHDR_ENDLOOP，分别表示循环时缓冲区的开始部分和结束部分。因为RECORD1只使用一个缓冲区来播放声音，所以这两个标记组合到了dwFlags字段。      
要实作两倍速播放也很容易。在准备为输出而打开波形声音期间，初始化WAVEFORMATEX结构的字段时，只需将nSamplesPerSec和nAvgBytesPerSec字段设定为22050，而不是11025。   
> realloc和malloc的区别
### 另一种MCI界面 
RECORD1在处理声波声音函数调用和它们产生的消息间的交互时很复杂。处理可能出现的内存不足的情况也是如此。但这也许正是它称为低阶界面的原因。而Windows也提供高阶媒体控制接口MCI（Media Control Interface）。    
对波形声音来说，低阶接口与MCI之间的主要区别在于**MCI用波形文件记录声音数据，并通过读取文件来播放声音**。由于在播放声音之前要读取文件、处理文件然后再写入文件，所以让RECODE1来实作「特殊效果」很困难。这是典型的折衷选择问题：功能齐全或是使用方便？低阶接口很灵活，但MCI（其中的大部分）更方便。   
MCI有两种不同但又相关的实作形式。一种形式用消息和数据结构将命令发送给多媒体设备，然后再从那里接收信息。另一种形式使用ASCII文字字符串。建立文字命令的接口最初是为了让多媒体设备接受简单的描述命令语言的控制。但它也提供非常容易的交谈式控制，请参见本章前面，TESTMCI程序的展示。   
RECORD2程序，使用MCI形式的消息和数据结构来实作另一个数字声音录音机和播放器。虽然它使用的对话框模板与RECORD1一样，但并没有实作三个特殊效果的按钮。    
**参考RECORD2**    

### MCI命令字符串的方法
参考RECORD3
### 波形声音文件格式
### 迭加合成实验
参考ADDSYNTH
### 起床号波形声音
参考WAKEUP