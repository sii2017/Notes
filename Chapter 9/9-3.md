## 编辑类别
在某些情况下，编辑类别是最简单的预先定义窗口类别；同时在另一方面，他又是最复杂的。我们使用类别名称“edit”来建立子窗口。在这个子窗口里可以编辑文字，可以获得输入焦点，移动光标等等。  
参考 POPPAD1  
这是一个多行编辑器，能换行，也有滚动条。但是他有一个问题就是由edit作为窗口类创建的子控件编辑框只能容纳3000个字符。   
### 编辑类别样式
由edit作为窗口类创建的子控件编辑框，使用窗口样式ES_LEFT,ES_RIGHT和ES_CENTER可以指定左对齐、右对齐和居中。   
默认情况下编辑控件是单行的，可以通过ES_MULTILINE窗口样式建立多行编辑控件。该情况下文字会自动换行，除非使用了ES_AUTOHSCROLL，则会自动拉出水平滚动条。   
WS_BORDER增加了编辑框的边界。
### 编辑控件通知
编辑控件给父窗口发送的WM_COMMAND消息与按钮控件是一样的
> LOWORD(wPARAM) 子窗口ID  
> HIWORD(wParam) 通知码  
> lParam 子窗口句柄  

具体通知码内容如下：  
> EN_SETFOCUS 编辑控件获得输入焦点  
> EN_KILLFOCUS 编辑控件失去输入焦点   
> EN_CHANGE 编辑控件的内容将改变   
> EN_UPDATE  编辑控件的内容已经改变   
> EN_ERRSPACE 编辑控件执行已经超出控件   
> EN_MAXTEXT 编辑控件在插入时超出控件   
> EN_HSCROLL 编辑控件的水平滚动条已经被按下   
> EN_VSCROLL 编辑控件的垂直滚动条已经被按下
### 使用编辑控件
如果在主窗口中使用了几个单行编辑控件，那么需要将窗口子类别化（指定新的子窗口控件消息处理程序）以便把输入焦点从一个控件转移到另一个控件。
### 发送给编辑控件的消息
一些操作通过给编辑控件发消息来进行，以下：  
```c
SendMessage(hwndEdit, WM_CUT,0,0);//对选择文字剪切   
SendMessage(hwndEdit, WM_COPY，0,0);//对选择文字复制  
SendMessage(hwndEdit, WM_CLEAR,0,0);//将选择文字删除   
SendMessage(hwndEdit, WM_PASTE,0,0);//将剪切板上的文字插入到光标位置  
SendMessage(hwndEdit, EM_GETSEL, (WPARAM)&iStart, (LPARAM)&iEnd);//去的目前选择的起始位置和末尾位置，结束位置实际上是最后一个位置加1   
SendMessage(hwndEdit, EM_SETSEL, iStart, iEnd);//选择文字  
iCount= SendMessage(hwndEdit,  EM_GETLINECOUNT,0,0);//取得行数   
iOffset= SendMessage(hwndEdit, EM_LINEINDEX, iLine, 0);//取得开头文字的偏移量   
iLength= SendMessage(hwndEdit, EM_LINELENGTH, iLine, 0);//取得行的长度   
iLength= SendMessage(hwndEdit, EM_GETLINE, iLine, (LPARAM)szBuffer);//将本身复制到一个缓冲区中   
```
## 清单方块类别
本章讨论的最后一个预定义子窗口控件是清单方块（已经讨论了按钮子控件和编辑子控件）。   
一个清单方块是字符串的集合，这些字符串可以卷动显示，并且可以被选中。当其中的**某一项或几项**（可以多选）被选中时，会向父窗口发送WM_COMMAND消息。被选中的项目加亮反色显示。   
清单方块中可以键盘，space键可以作为点击，方向键可以移动等等。
### 清单方块样式
我们使用“listbox”作为预定义窗口类别来创建清单方块的子窗口控件。以下为清单方块样式可能会使用到的窗口样式：  
> WM_CHILD 子窗口样式   
> LBS_NOTIFY 一般清单不像父窗口发送消息（程序必须向清单方块询问其中的项目的选择状态），那么父窗口也不接收消息，这个样式允许父窗口接收来自清单方块的消息。   
> LBS_SORT 对清单方块中的项目进行排序    
> LBS_MULTIPLESEL 可以多选    
> LBS_NOREDRAW 一般清单方块增加新项目时本身会重画，可以使用这个样式防止防止这个情况（节约资源？）   
> WM_SETREDRAW 另一种方式暂时防止清单方块控件重新画过（后面将讨论）   
> WS_BORDER 清单方块本身没有边框，可以用此来添加  
> windows头文件定义了一个“清单方块样式”，叫LBS_STANDARD，它包含了最常用的样式：（LBS_NOTIFY|LBS_SORT|WS_VSCROLL|WS_BORDER)   
> WS_SIZEBOX和WS_CAPTION标识符，允许我们重新定义清单方块的大小，也允许在父窗口的显示区域移动清单方块。  
### 将字符串放入清单方块
我们通过调用SendMessage给清单方块的消息处理程序发送消息来将字符串放入。  
字符串通常通过以0开始计数的索引数来引用，其中0对应于最顶上的项目。   
当窗口消息处理程序存储的清单方块内容超过了可用内存空间时，SendMessage将返回LB_ERRSPACE(定义为-2)。如果是因为其他原因出错，SendMessage传回LB_ERR（-1）。如果操作成功，那么SendMessage将传回LB_OKAY（0）。   
```c
SendMessage (hwndList, LB_ADDSTRING, 0, (LPARAM) szString) ;//在LBS_SORT的情况下，能依次插入字符串  
SendMessage (hwndList, LB_INSERTSTRING, iIndex, (LPARAM) szString);//如果没有采用LBS_SORT可以用这个函数，第三个参数为索引   
SendMessage (hwndList, LB_DELETESTRING, iIndex, 0);//根据索引从清单方块中删除字符串   
SendMessage (hwndList, LB_RESETCONTENT, 0, 0);//清楚清单方块中的内容   
SendMessage (hwndList, WM_SETREDRAW, FALSE, 0);//如果有许多内容需要修改，FALSE可以暂时关掉清单方块的重画功能，当我们做好修改，将FALSE变成TRUE即可。  
//使用LBS_NOREDRAW样式建立的清单方块开始时其重画旗标是关闭的。   
```
### 选项和取得项
这里同样大部分也是用SendMessage函数完成的，如果失败的话会返回LB_ERR(定义为-1）  
```c
iCount = SendMessage (hwndList, LB_GETCOUNT, 0, 0);//获取清单方块中的项目数量   
```
其中的一些调用对于单选清单方块和多选清单方块是不同的。我们先看单选清单方块。    
```c
SendMessage (hwndList, LB_SETCURSEL, iIndex, 0);//加亮显示作为一个默认选择，将lParam设定为-1则是取消所有选择  
```
### 接收来自清单方块的消息
### 一个简单的清单方块应用程序
参考ENVIRON.C
### 文件列表
### 使用文件属性码
### 文件列表的排序
### windows的head程序
参考HEAD.C