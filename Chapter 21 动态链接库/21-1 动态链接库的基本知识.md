# 第二十一章 动态链接库
动态链接库（也称为DLL）是Windows最重要的组成要素之一。大多数与Windows相关的磁盘文件如果不是程序模块，就是动态链接程序。  
许多编写应用程序的规则同样适用于编写动态链接库模块，但也有一些重要的不同。
## 动态链接库的基本知识
通常，动态链接库并不能直接执行，也不接收消息。它们是一些独立的文件，其中包含能被程序或其它DLL呼叫来完成一定作业的函数。只有在其它模块呼叫动态链接库中的函数时，它才发挥作用。   
所谓「**动态链接**」，是指Windows把一个模块中的函数呼叫连结到动态链接库模块中的实际函数上的程序。   
而「**静态连结**」。是指将各种目标模块(.OBJ)、执行时期链接库(.LIB)文件，以及经常是已编译的资源(.RES)文件连结在一起，以便建立Windows的.EXE文件。**动态链接与此不同，它发生在执行时期，而非静态链接的编译连接时期**。     
KERNEL32.DLL、USER32.DLL和GDI32.DLL、各种驱动程序文件如KEYBOARD.DRV、SYSTEM.DRV和MOUSE.DRV和视讯及打印机驱动程序都是动态链接库。**这些动态链接库（中的函数）能被所有Windows应用程序使用。也有些动态链接库（如字体文件等）被称为「纯资源」。它们只包含数据（通常是资源的形式）而不包含程序代码**。     
尽管一个动态链接库模块可能有其它扩展名（如.EXE或.FON），但标准扩展名是.DLL。只有带.DLL扩展名的动态链接库才能被Windows自动加载。如果文件有其它扩展名，则程序必须另外使用LoadLibrary或者LoadLibraryEx函数加载该模块。（静态链接库的扩展名是.lib）   
动态链接库在大型应用程序中最有意义。   
例如，假设要为Windows编写一个由几个不同的程序组成的大型财务软件包，会发现这些程序将使用许多相同的函数。   
这时可以把这些公共例程放入一个一般性的静态链接库（带.LIB扩展名）中，并在使用LINK静态连结时把它们加入各程序模块中。但这种方法是很浪费的，因为静态链接库的加载方式是将静态链接库里的代码完全复制到每一个链接它的程序中，因此会有多份被复制且完全相同的代码，并且全部并入到EXE文件中。而且，如果修改了链接库中的某个例程，就要重新连结使用此例程的所有程序。   
然而，如果把这些公共例程放到称为ACCOUNT.DLL的动态链接库中，就可解决这两个问题。只有动态链接库模块才包含所有程序都要用到的函数。这样能为储存文件节省磁盘空间，因为动态加载并不会将代码挨个复制到动态链接的程序中所有的函数本着“有需求才调入”的原则，大大节省了系统资源。而且，可以修改动态链接库模块而不用重新连结各个程序。    
### 一个简单的DLL
虽然动态链接库的概念是它们可以被多个应用程序使用加载，但是作为我们最初将要设计的动态链接库，可以只与一个应用程序联系，是一个测试用的DLL。   
下面就是我们要做的。我们建立一个名为EDRLIB.DLL的DLL。文件名中的「EDR」代表「简便的绘图例程（easy drawing routines）」。这里的EDRLIB只含有一个函数（名称为EdrCenterText），但是您还可以将应用程序中其它简单的绘图函数添加进去。应用程序EDRTEST.EXE将通过呼叫EDRLIB.DLL中的函数来利用它。    
要做到这一点，需要与我们以前所做的略有不同的方法，也包括Visual C++ 中我们没有看过的特性。在Visual C++ 中「工作空间（workspaces）」和「项目（projects）」不同。项目通常与建立的应用程序（.EXE）或者动态链接库（.DLL）相联系。一个工作空间可以包含一个或多个项目。迄今为止，我们所有的工作空间都只包含一个项目。我们现在就建立一个包含两个项目的工作空间EDRTEST－一个用于建立EDRTEST.EXE，而另一个用于建立EDRLIB.DLL，即EDRTEST使用的动态链接库。
参考EDRLIB
右键项目build后，dll文件建立在了debug文件目录下。   
纵观全书，我们建立的所有程序都可以根据UNICODE标识符来编译成使用Unicode或非Unicode字符串的程序代码。当您建立一个DLL时，它应该包括处理字符和字符串的Unicode和非Unicode版的所有函数。因此，EDRLIB.C就包含函数EdrCenterTextA（ANSI版）和EdrCenterTextW（宽字符版）。EdrCenterTextA定义为带有参数PCSTR（指向const字符串的指针），而EdrCenterTextW则定义为带有参数PCWSTR（指向const宽字符串的指针）。EdrCenterTextA函数将呼叫lstrlenA、GetTextExtentPoint32A和TextOutA。EdrCenterTextW将呼叫lstrlenW、GetTextExtentPoint32W和TextOutW。如果定义了UNICODE标识符，则EDRLIB.H将EdrCenterText定义为EdrCenterTextW，否则定义为EdrCenterTextA。这样的做法很像Windows表头文件。    
EDRLIB.H也包含函数DllMain，取代了DLL中的WinMain。此函数用于执行初始化和未初始化（deinitialization）。    
在这两个文件中，定义了EXPORT标识符。DLL中应用程序使用的函数必须是「输出（exported）」的。这是确保函数名添加到EDRLIB.LIB的一个关键词（以便连结程序在连结使用此函数的应用程序时，能够解析出函数名称），而且该函数在EDRLIB.DLL中也是看得到的。EXPORT标识符包括储存方式限定词__declspec（dllexport）以及在表头文件按C++模式编译时附加的「C」。这将防止编译器使用C++的名称轧压规则（name mangling）来处理函数名称，使C和C++程序都能使用这个DLL。
### 链接库入口/出口点
### 测试程序
参考EDRTEST
### 在DLL中共享内存
参考STRLI
### STRPROG程序
参考STRPROG
### 在STRPROG执行实体之间共享数据