## 事件信号
多线程通常是用于那些必须执行长时间处理的程序。    
我们可以将一个「大作业」定义为一个**可能**会违反1/10秒规则的程序。显然大作业包括文书处理程序中的拼写检查、数据库程序中的文件排序或者索引、电子表格的重新计算、打印，甚至包括复杂的绘图。当然，迄今为止我们知道，遵循1/10秒规则的最好方法是将大作业放到另一个线程去执行。这些额外的执行绪不会建立窗口，因此它们不受1/10秒规则的限制。
通常希望这些额外的线程在完成其任务时能够通知主线程，或者主线程能够停止其它线程正在进行的作业。这就是我们下面将要讨论的。  
### BIGJOB1程序
作为一个想象的大作业，我们将使用一系列浮点运算，有时这种运算被称为「暴力的」性能测试指针。  
这种计算以一种间接的方式递增一个整数的值：**它求一个数的平方，再对结果取平方根（得到原来的整数），然后使用log和exp函数（同样得到原来的整数），接着使用atan和tan函数（还是得到原来的整数），最后对结果加1。**    
参考BIGJOB1.C    
这是一个相当简单的程序。为了使用BIGJOB1程序，在窗口的显示区域中按下鼠标左键，从而开始暴力的性能测试计算的1,000,000次重复，这在一台300MHz的Pentium II机器上将花费2秒（实际上在现在的电脑测试10，000，000粗成功i办公费用，也只要2秒）。当完成计算时，花费的时间将显示在窗口上。当正在进行计算时，可以通过在显示区域中按下鼠标右键来终止它。   
Thread中的pparams变量定义为volatile，**这种型态限定字向编译器指出变量可能会在实际的程序叙述外被修改（例如被另一个线程）。否则，最佳化的编译器会假设pparams->bContinue不能被for循环内的程序代码修改，没有必要在每层循环中检查变量。**volatile关键词防止这样的最佳化进行。   
### 时间对象
BIGJOB1在每次需要执行暴力测试计算时，就建立一个执行绪（执行的线程）。执行绪在完成计算之后自动终止。   
**另一种可用的方法是在程序的整个生命周期内保持线程的执行，但是只在必要时才启动它。**这是一个应用事件对象的理想情况。   
事件对象可以是「有信号的」（也称为「被设立的」）或「没信号的」（也称为「被重置的」）。您可以通过下面呼叫来建立事件对象：   
```c
hEvent= CreateEvent(&sa, fManual, fInitial, pszName);   
```   
第一个参数（指向一个SECURITY_ATTRIBUTES结构的指针）和最后一个参数（一个事件对象的名字）只有在事件对象被多个程序共享时才有意义。在同一程序中，这些参数通常被设定为NULL。   
如果希望事件对象被初始化为有信号的，那么将fInitial参数设定为TRUE。而如果希望事件对象被初始化为无信号的，则将fInitial参数设定为FALSE。   
以下为相关的函数调用：   
```c
SetEvent(hEvent);   //设立一个现存的时间对象（可以理解为发送信号，并且因此某个调用了WaitForSingleObject的线程可以开始运作）    
ResetEvent(hEvent);	//重置一个事件对象（如果自动重置就不需要这个函数了）   
```    
一个程序通常调用：   
```c
WaitForSingleObject(hEvent, dwTimeOut);   
```   
并且将第二个参数设定为INFINITE（无限）。如果事件对象目前是被设立的，那么函数将立即传回，否则，函数将暂停线程直到事件对象被设立。如果将第二个参数设定为一个以毫秒计的超时时间值，这样函数也可能在事件对象被设立之前传回。   
如果最初的CreateEvent呼叫的fManual参数被设定为FALSE，那么事件对象将在WaitForSingleObject函数传回时自动重置。这种功能特性通常使得事件对象没有必要使用ResetEvent函数。    
参考BIGJOB2.C   
在处理WM_CREATE消息时，窗口消息处理程序首先建立一个初始化为没信号的自动重置事件对象，然后建立线程。    
Thread函数进入一个无限的while循环，在循环开始时首先呼叫WaitForSingleObject（注意PARAMS结构包括一个包含事件对象句柄的字段）。因为事件被初始化为重置的，所以线程的执行被阻挡在函数呼叫中。按下鼠标左键将导致窗口过程调用SetEvent，这将释放由WaitForSingleObject呼叫产生的第二个线程，并开始暴力测试计算。当计算完之后，线程再次呼叫WaitForSingleObject，但是由于第一次呼叫已经使事件对象重置，因此，线程将被暂停，直到再次按下鼠标。   
在其它方面，程序几乎和BIGJOB1完全一样。
