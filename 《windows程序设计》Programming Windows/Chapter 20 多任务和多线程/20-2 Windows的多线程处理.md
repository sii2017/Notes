## Windows的多线程处理
建立新的线程的API函数是CreateThread，它的语法如下：   
```c
hThread= CreateThread (&security_attributes, dwStackSize, ThreadProc, pParam, dwFlags, &idThread);   
```   
第一个参数是指向SECURITY_ATTRIBUTES型态的结构的指针。在Windows 98中忽略该参数。在Windows NT中，它被设为NULL。    
第二个参数是用于新线程的初始堆栈大小，默认值为0。**在任何情况下，Windows根据需要动态延长堆栈的大小**。   
第三个参数是指向线程函数的指标。函数名称没有限制，但是必须以下列形式声明：    
```c
DWORD WINAPI ThreadProc (PVOID pParam);   
```   
第四个参数为传递给ThreadProc的参数。这样主线程和从属线程就可以共享数据。   
第五个参数通常为0，但当建立的线程不马上执行时为旗标CREATE_SUSPENDED。线程将暂停直到呼叫ResumeThread来恢复线程的执行为止。    
第六个参数是一个指针，指向接受执行绪ID值的变量。   
大多数Windows程序写作者喜欢用在PROCESS.H表头文件中声明的C执行时期链接库函数_beginthread来替代CreateThread。它的语法如下：   
```c
hThread = _beginthread (ThreadProc, uiStackSize, pParam) ;   
```    
它更简单，对于大多数应用程序很完美，这个线程函数的语法为：   
```c    
void __cdecl ThreadProc (void * pParam) ;   
```   
### 再论随机矩形
RNDRCTMT是第五章里的RANDRECT程序的多线程版本。   
参考RNDRCTMT.C   
窗口消息处理程序以最容易的方法调用_beginthread－简单地以线程函数的地址（称为Thread）作为第一个参数，其它参数使用0，线程函数传回VOID并有一个参数，该参数是一个指向VOID的指标。在RNDRCTMT中的Thread函数不使用这个参数。  
在调用了_beginthread函数之后，线程函数（以及该线程函数可能呼叫的其它任何函数）中的程序代码和程序中的其它程序代码**同时执行**。两个或者多个执行绪使用一个程序中的同一函数，在这种情况下，动态区域变量（储存在堆栈上）对每个执行绪是唯一的。对程序中的所有执行绪来说，所有的静态变量都是一样的。因此设定cxClient和cyClient为全局变量来给线程函数使用。    
有时您需要唯一于各个线程的持续储存性数据。通常，这种数据是静态变量，但在Windows 98中，可以使用「线程区域储存空间」，我将在本章后面进行讨论。     
### 程序设计竞赛的问题
1986年10月3日，Microsoft举行了为期一天，针对计算机杂志出版社的技术编辑和作者的简短的记者招待会，来讨论他们当时的一组语言产品，包括他们的第一个交谈式开发环境，QuickBASIC 2.0。当时，Windows 1.0出现还不到一年，但是没有人知道我们什么时候能得到与该环境类似的东西（这花了好几年）。这一事件与众不同的部分原因是由于Microsoft的公关人员所举办的「Storm the Gates」程序设计竞赛。Bill Gates使用QuickBASIC 2.0，而计算机出版社的人员可以使用他们选择的任何语言产品。    
竞赛的问题是从公众提出的题目中挑选出来的（挑选那些需要写大约半小时程序来解决的问题），问题如下：    
> 建立一个包含四个窗口的多任务仿真程序。第一个窗口必须显示一系列的递增数，第二个必须显示一系列的递增质数，而第三个必须显示Fibonacci数列（Fibonacci数列以数字0和1开始，后头每一个数都是其前两个数的和－即0、1、1、2、3、5、8等等）。这三个窗口应该在数字达到窗口底部时或者进行滚动，或者自行清除窗口内容。第四个窗口必须显示任意半径的圆，而程序必须在按下一个Escape键时终止。   
  
当然，在1986年10月，在DOS下执行的这样一个程序最多只能是模拟多任务而已。   
参加这次竞赛的大多数人编写了一个程序来将屏幕分为四个区域，程序中包含一个循环，依次更新每个窗口，然后检查是否按下了Escape键。如同DOS环境下的传统习惯，程序占用了百分之百的CPU处理时间。   
如果在Windows 1.0中写程序，那么结果将是类似程序MULTI1的结果。我说「类似」，是因为我编写的程序是32位的，但程序结构和相当多的程序代码－除了变量和函数参数定义以及Unicode支持－都是相同的。     
参考MULTI1.C   
主窗口创建四个子窗口，并且做一个定时器分别发送给四个子窗口更新内容。（关于为何使用APIENTRY代替CALLBACK意义不明，就代码上来分析两者效果是一样的，并且替换后也可以正常运行。）    
MULTI1程序没有什么不好的地方。使用Windows定时器是在Windows的早期（和目前）版本中模拟多任务的一种好方法，然而，定时器的使用有时限制了程序的速度。如果程序可以在WM_TIMER消息处理中更新它的所有窗口而还有时间剩余下来的话，那就意味着它并没有充分利用我们的机器资源。    
一种可能的解决方案是在单个WM_TIMER消息处理期间进行两次或者更多次的更新，但是到底多少次呢？这不得不依赖于机器的速度，而有很大的变动性。速度慢的机器可能满载，而速度快的机器可能有很大的性能剩余。这里的问题就是，一个简单的程序不该受限于机器的性能，而如果我们用多线程来解决，就能摆脱这个问题。    
### 多线程解决方案
多线程解决方案MULT2。  
参考MULTI2.C    
MULTI2是前一个程序的改良版，这个版本里不再使用计时器，而是为每一个子窗口建立了独立的线程，同时不断的进行需求上的循环。  
在主窗口建立的时候WM_CREATE中便会依照次序创建四个子窗口，创建好以后就不用管他们了，在四个子窗口各自的WM_CREATE周继红会用_beginthread函数来建立自己的线程。直到执行_endthread()才结束。以下为建立线程的函数：   
```c
void Thread1(PVOID pvoid)   
{    
	//需求内容代码   
	_endthread();   
}     
_beginthread(Thread1, 0, &params);    
```   
这里我们使用了该函数的第三个参数，使原线程和新线程可以共享变量。通常，这个变量是一个指针，而且是指向一个结构的指针。   
在WM_DESTROY消息处理期间，它将bKill字段设定为TRUE。Thread1函数通过对_endthread的呼叫而告结束。这并不是绝对必要的，因为线程将在退出线程函数之后被清除。   
执行MULTI2时，窗口更新要比在MULTI1中快得多，这表示程序在更加有效地利用处理器的资源。在MULTI1和MULTI2之间还有另一种区别：通常，当您移动或者缩放一个窗口时，内定窗口消息处理程序进入一种模态循环，而窗口的所有输出都将停止。在MULTI2中，输出将继续。    
### 有问题嘛？
**第一个问题是MULTI2程序并不是那么稳固，以WndProc1和Thread1为例**。    
WndProc1在MULTI2的主线程中执行，而Thread1与它同时执行，Windows 98在这两个线程之间进行切换是不可预测的。假定Thread1正在执行，并且刚好执行了检查PARAMS结构的bKill字段是否为TRUE的程序代码。发现不为TRUE，但是这之后Windows 98将控制权切换到主线程，这时使用者终止了程序，WndProc1收到一个WM_DESTROY消息并将bKill参数设为TRUE。哦，这参数设定得太晚了！操作系统突然切换到Thread1中，（这时候已经destroy了）而该函数会试图取得一个不存在的窗口的设备内容句柄。   
> 这里书上说的比较繁琐，做一个总结。WndProc1是在主线程中调用的，Thread1是在线程1中调用的。当线程1的while循环刚判断好，bKill不是TURE，正确进入循环以后的这个瞬间，主线程关闭了窗口并且发送了WM_DESTROY给了WndProc1。这个瞬间在线程1的while循环之间，导致窗口已经被结束了，但是仍然会继续调用GetDC函数，直到下次while循环判断bKill是否是TRUE为止。这并不严谨，对于不稳定的系统容易造成崩溃。     
      
事实证明，这不是一个问题。Windows 98够稳固，以致另一条线程呼叫的图形处理函数只是失败而已，而不会引起任何问题。   
正确的多线程程序写作技术涉及线程同步的使用（**尤其是临界区域的使用**）。大体上，临界区域通过调用函数EnterCriticalSection和LeaveCriticalSection加以界定。如果一个线程进入一个临界区域，那么另一个线程将无法再进入这个临界区域。后一个线程被阻档，如果调用了EnterCriticalSection，直到前一个线程调用LeaveCriticalSection时为止。   
第二个问题是，当另外一个线程显示其输出时，主线程可能会收到一个WM_ERASEBKGND或WM_PAINT消息。    
这里使用临界区域有助于避免当两个程序试图在同一个窗口上绘图时可能导致的任何问题。但是，经验显示，Windows 98很恰当地序列化了对图形绘制函数的存取。当一个线程正在绘图的时候，另一个线程不能在同一个窗口上绘图。     
Windows 98文件提醒说，有一种未进行图形函数序列化的情形，这就是GDI对象（如画笔、画刷、字体、位图、区域和调色盘等）的使用。有可能发生一个线程清除了一个对象，而另一个线程仍然在使用它的情况。解决这个问题的方法要求使用临界区域，或者**最好不要在线程之间共享GDI对象**。    
### Sleep的好处
之前说过，最好的架构是主线程建立程序中的所有窗口，以及所有的窗口消息处理程序，并处理所有的窗口消息。其它线程完成背景工作或者冗长作业。   
不过，假设您想在另一个线程中做动画。通常，Windows中的动画是使用WM_TIMER消息来实作的。如果这个线程没有建立窗口，那么它也不会收到这些消息。如果没有定时器，动画又可能会执行得太快。   
解决方案是Sleep函数。实际上，线程呼叫Sleep函数来自动暂停执行，该函数唯一一个参数是以毫秒计的时间。Sleep函数呼叫在指定的时间过去以前不会传回控制权。在这段时间内，线程被暂停，并且不会被配置给时间片段（尽管该线程显然仍然要求在tick时给予一小段的处理时间，因为系统必须确定线程是否应该重新开始执行）。给Sleep一个值为0的参数将导致线程交回它尚未使用完的时间片段。    
> 当 timeout = 0， 即 Sleep(0)，如果线程调度器的可运行队列中有大于或等于当前线程优先级的就绪线程存在，操作系统会将当前线程从处理器上移除，调度其他优先级高的就绪线程运行；如果可运行队列中的没有就绪线程或所有就绪线程的优先级均低于当前线程优先级，那么当前线程会继续执行，就像没有调用 Sleep(0)一样。    
当 timeout > 0 时，如：Sleep(1)，会引发线程上下文切换：调用线程会从线程调度器的可运行队列中被移除一段时间，这个时间段约等于 timeout 所指定的时间长度。为什么说约等于呢？是因为睡眠时间单位为毫秒，这与系统的时间精度有关。通常情况下，系统的时间精度为 10 ms，那么指定任意少于 10 ms但大于 0 ms 的睡眠时间，均会向上求值为 10 ms。    
   
当一个线程呼叫Sleep时，只是该线程被暂停指定的时间。系统仍然执行其它的执行绪，这些执行绪和暂停的执行绪可以是在同一个程序中，也可以是在另一个程序中。   
通常，不应该在主线程中使用Sleep函数，因为这会减慢对消息的处理速度，但是因为SCRAMBLE没有建立任何窗口，因此在那里使用Sleep应该没有问题。       